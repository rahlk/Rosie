{"cs.functions":{"subs":[{"cs.function":{"subs":[{"cs.accessmod":{"pos":1925,"text":"internal"}},{"cs.returntype":{"pos":1934,"text":"int"}},{"cs.methodname":{"pos":1938,"text":"CalculateLength"}}],"pos":1925,"text":"internal int CalculateLength()\n        {"}},{"cs.function":{"subs":[{"cs.accessmod":{"pos":2397,"text":"internal"}},{"cs.returntype":{"pos":2406,"text":"void"}},{"cs.methodname":{"pos":2411,"text":"WriteTo"}},{"cs.paramlist":{"subs":[{"cs.param":{"subs":[{"cs.paramtype":{"pos":2419,"text":"StringBuilder"}},{"cs.paramname":{"pos":2433,"text":"sb"}}],"pos":2419,"text":"StringBuilder sb"}}],"pos":2419,"text":"StringBuilder sb"}}],"pos":2397,"text":"internal void WriteTo(StringBuilder sb)\n        {"}},{"cs.function":{"subs":[{"cs.accessmod":{"pos":3397,"text":"internal"}},{"cs.mod":{"pos":3406,"text":"static"}},{"cs.returntype":{"pos":3413,"text":"bool"}},{"cs.methodname":{"pos":3418,"text":"TypeHasIndex"}},{"cs.paramlist":{"subs":[{"cs.param":{"subs":[{"cs.paramtype":{"pos":3431,"text":"JsonContainerType"}},{"cs.paramname":{"pos":3449,"text":"type"}}],"pos":3431,"text":"JsonContainerType type"}}],"pos":3431,"text":"JsonContainerType type"}}],"pos":3397,"text":"internal static bool TypeHasIndex(JsonContainerType type)\n        {"}},{"cs.function":{"subs":[{"cs.accessmod":{"pos":3579,"text":"internal"}},{"cs.mod":{"pos":3588,"text":"static"}},{"cs.returntype":{"pos":3595,"text":"string"}},{"cs.methodname":{"pos":3602,"text":"BuildPath"}},{"cs.paramlist":{"subs":[{"cs.param":{"subs":[{"cs.paramtype":{"pos":3612,"text":"List<JsonPosition>"}},{"cs.paramname":{"pos":3631,"text":"positions"}}],"pos":3612,"text":"List<JsonPosition> positions"}},{"cs.param":{"subs":[{"cs.paramtype":{"pos":3642,"text":"JsonPosition?"}},{"cs.paramname":{"pos":3656,"text":"currentPosition"}}],"pos":3642,"text":"JsonPosition? currentPosition"}}],"pos":3612,"text":"List<JsonPosition> positions, JsonPosition? currentPosition"}}],"pos":3579,"text":"internal static string BuildPath(List<JsonPosition> positions, JsonPosition? currentPosition)\n        {"}},{"cs.function":{"subs":[{"cs.accessmod":{"pos":4531,"text":"internal"}},{"cs.mod":{"pos":4540,"text":"static"}},{"cs.returntype":{"pos":4547,"text":"string"}},{"cs.methodname":{"pos":4554,"text":"FormatMessage"}},{"cs.paramlist":{"subs":[{"cs.param":{"subs":[{"cs.paramtype":{"pos":4568,"text":"IJsonLineInfo"}},{"cs.paramname":{"pos":4582,"text":"lineInfo"}}],"pos":4568,"text":"IJsonLineInfo lineInfo"}},{"cs.param":{"subs":[{"cs.paramtype":{"pos":4592,"text":"string"}},{"cs.paramname":{"pos":4599,"text":"path"}}],"pos":4592,"text":"string path"}},{"cs.param":{"subs":[{"cs.paramtype":{"pos":4605,"text":"string"}},{"cs.paramname":{"pos":4612,"text":"message"}}],"pos":4605,"text":"string message"}}],"pos":4568,"text":"IJsonLineInfo lineInfo, string path, string message"}}],"pos":4531,"text":"internal static string FormatMessage(IJsonLineInfo lineInfo, string path, string message)\n        {"}}],"pos":1,"text":"#region License\n\/\/ Copyright (c) 2007 James Newton-King\n\/\/\n\/\/ Permission is hereby granted, free of charge, to any person\n\/\/ obtaining a copy of this software and associated documentation\n\/\/ files (the \"Software\"), to deal in the Software without\n\/\/ restriction, including without limitation the rights to use,\n\/\/ copy, modify, merge, publish, distribute, sublicense, and\/or sell\n\/\/ copies of the Software, and to permit persons to whom the\n\/\/ Software is furnished to do so, subject to the following\n\/\/ conditions:\n\/\/\n\/\/ The above copyright notice and this permission notice shall be\n\/\/ included in all copies or substantial portions of the Software.\n\/\/\n\/\/ THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n\/\/ EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n\/\/ OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n\/\/ NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n\/\/ HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n\/\/ WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n\/\/ FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n\/\/ OTHER DEALINGS IN THE SOFTWARE.\n#endregion\n\nusing System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Text;\nusing Newtonsoft.Json.Utilities;\n\nnamespace Newtonsoft.Json\n{\n    internal enum JsonContainerType\n    {\n        None = 0,\n        Object = 1,\n        Array = 2,\n        Constructor = 3\n    }\n\n    internal struct JsonPosition\n    {\n        private static readonly char[] SpecialCharacters = { '.', ' ', '[', ']', '(', ')' };\n\n        internal JsonContainerType Type;\n        internal int Position;\n        internal string PropertyName;\n        internal bool HasIndex;\n\n        public JsonPosition(JsonContainerType type)\n        {\n            Type = type;\n            HasIndex = TypeHasIndex(type);\n            Position = -1;\n            PropertyName = null;\n        }\n\n        internal int CalculateLength()\n        {\n            switch (Type)\n            {\n                case JsonContainerType.Object:\n                    return PropertyName.Length + 5;\n                case JsonContainerType.Array:\n                case JsonContainerType.Constructor:\n                    return MathUtils.IntLength((ulong)Position) + 2;\n                default:\n                    throw new ArgumentOutOfRangeException(\"Type\");\n            }\n        }\n\n        internal void WriteTo(StringBuilder sb)\n        {\n            switch (Type)\n            {\n                case JsonContainerType.Object:\n                    string propertyName = PropertyName;\n                    if (propertyName.IndexOfAny(SpecialCharacters) != -1)\n                    {\n                        sb.Append(@\"['\");\n                        sb.Append(propertyName);\n                        sb.Append(@\"']\");\n                    }\n                    else\n                    {\n                        if (sb.Length > 0)\n                        {\n                            sb.Append('.');\n                        }\n\n                        sb.Append(propertyName);\n                    }\n                    break;\n                case JsonContainerType.Array:\n                case JsonContainerType.Constructor:\n                    sb.Append('[');\n                    sb.Append(Position);\n                    sb.Append(']');\n                    break;\n            }\n        }\n\n        internal static bool TypeHasIndex(JsonContainerType type)\n        {\n            return (type == JsonContainerType.Array || type == JsonContainerType.Constructor);\n        }\n\n        internal static string BuildPath(List<JsonPosition> positions, JsonPosition? currentPosition)\n        {\n            int capacity = 0;\n            if (positions != null)\n            {\n                for (int i = 0; i < positions.Count; i++)\n                {\n                    capacity += positions[i].CalculateLength();\n                }\n            }\n            if (currentPosition != null)\n            {\n                capacity += currentPosition.GetValueOrDefault().CalculateLength();\n            }\n\n            StringBuilder sb = new StringBuilder(capacity);\n            if (positions != null)\n            {\n                foreach (JsonPosition state in positions)\n                {\n                    state.WriteTo(sb);\n                }\n            }\n            if (currentPosition != null)\n            {\n                currentPosition.GetValueOrDefault().WriteTo(sb);\n            }\n\n            return sb.ToString();\n        }\n\n        internal static string FormatMessage(IJsonLineInfo lineInfo, string path, string message)\n        {\n            \/\/ don't add a fullstop and space when message ends with a new line\n            if (!message.EndsWith(Environment.NewLine, StringComparison.Ordinal))\n            {\n                message = message.Trim();\n\n                if (!message.EndsWith('.'))\n                {\n                    message += \".\";\n                }\n\n                message += \" \";\n            }\n\n            message += \"Path '{0}'\".FormatWith(CultureInfo.InvariantCulture, path);\n\n            if (lineInfo != null && lineInfo.HasLineInfo())\n            {\n                message += \", line {0}, position {1}\".FormatWith(CultureInfo.InvariantCulture, lineInfo.LineNumber, lineInfo.LinePosition);\n            }\n\n            message += \".\";\n\n            return message;\n        }\n    }\n}\n"}}
