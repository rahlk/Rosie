{"rb.functions":{"text":"# Copyright (C) 2007, 2008, 2009, 2010 Christian Neukirchen <purl.org\/net\/chneukirchen>\n#\n# Rack is freely distributable under the terms of an MIT-style license.\n# See COPYING or http:\/\/www.opensource.org\/licenses\/mit-license.php.\n\nrequire \"time\"\nrequire 'rack\/utils'\nload 'rack\/mime'\nload \"rack\/request\"\nrequire_relative 'rack\/head'\n\nmodule Rack\n  # Rack::File serves files below the +root+ directory given, according to the\n  # path info of the Rack request.\n  # e.g. when Rack::File.new(\"\/etc\") is used, you can access 'passwd' file\n  # as http:\/\/localhost:9292\/passwd\n  #\n  # Handlers can detect if bodies are a Rack::File, and use mechanisms\n  # like sendfile on the +path+.\n\n  class File\n    ALLOWED_VERBS = %w[GET HEAD OPTIONS]\n    ALLOW_HEADER = ALLOWED_VERBS.join(', ')\n\n    attr_reader :root\n\n    def initialize(root, headers={}, default_mime = 'text\/plain')\n      @root = root\n      @headers = headers\n      @default_mime = default_mime\n      @head = Rack::Head.new(lambda { |env| get env })\n    end\n\n    def call(env)\n      # HEAD requests drop the response body, including 4xx error messages.\n      @head.call env\n    end\n\n    def get(env)\n      request = Rack::Request.new env\n      unless ALLOWED_VERBS.include? request.request_method\n        return fail(405, \"Method Not Allowed\", {'Allow' => ALLOW_HEADER})\n      end\n\n      path_info = Utils.unescape_path request.path_info\n      return fail(400, \"Bad Request\") unless Utils.valid_path?(path_info)\n\n      clean_path_info = Utils.clean_path_info(path_info)\n      path = ::File.join(@root, clean_path_info)\n\n      available = begin\n        ::File.file?(path) && ::File.readable?(path)\n      rescue SystemCallError\n        false\n      end\n\n      if available\n        serving(request, path)\n      else\n        fail(404, \"File not found: #{path_info}\")\n      end\n    end\n\n    def serving(request, path)\n      if request.options?\n        return [200, {'Allow' => ALLOW_HEADER, CONTENT_LENGTH => '0'}, []]\n      end\n      last_modified = ::File.mtime(path).httpdate\n      return [304, {}, []] if request.get_header('HTTP_IF_MODIFIED_SINCE') == last_modified\n\n      headers = { \"Last-Modified\" => last_modified }\n      mime_type = mime_type path, @default_mime\n      headers[CONTENT_TYPE] = mime_type if mime_type\n\n      # Set custom headers\n      @headers.each { |field, content| headers[field] = content } if @headers\n\n      response = [ 200, headers ]\n\n      size = filesize path\n\n      range = nil\n      ranges = Rack::Utils.get_byte_ranges(request.get_header('HTTP_RANGE'), size)\n      if ranges.nil? || ranges.length > 1\n        # No ranges, or multiple ranges (which we don't support):\n        # TODO: Support multiple byte-ranges\n        response[0] = 200\n        range = 0..size-1\n      elsif ranges.empty?\n        # Unsatisfiable. Return error, and file size:\n        response = fail(416, \"Byte range unsatisfiable\")\n        response[1][\"Content-Range\"] = \"bytes *\/#{size}\"\n        return response\n      else\n        # Partial content:\n        range = ranges[0]\n        response[0] = 206\n        response[1][\"Content-Range\"] = \"bytes #{range.begin}-#{range.end}\/#{size}\"\n        size = range.end - range.begin + 1\n      end\n\n      response[2] = [response_body] unless response_body.nil?\n\n      response[1][CONTENT_LENGTH] = size.to_s\n      response[2] = make_body request, path, range\n      response\n    end\n\n    class Iterator\n      attr_reader :path, :range\n      alias :to_path :path\n\n      def initialize path, range\n        @path  = path\n        @range = range\n      end\n\n      def each\n        ::File.open(path, \"rb\") do |file|\n          file.seek(range.begin)\n          remaining_len = range.end-range.begin+1\n          while remaining_len > 0\n            part = file.read([8192, remaining_len].min)\n            break unless part\n            remaining_len -= part.length\n\n            yield part\n          end\n        end\n      end\n\n      def close; end\n    end\n\n    private\n\n    def make_body request, path, range\n      if request.head?\n        []\n      else\n        Iterator.new path, range\n      end\n    end\n\n    def fail(status, body, headers = {})\n      body += \"\\n\"\n\n      [\n        status,\n        {\n          CONTENT_TYPE   => \"text\/plain\",\n          CONTENT_LENGTH => body.size.to_s,\n          \"X-Cascade\" => \"pass\"\n        }.merge!(headers),\n        [body]\n      ]\n    end\n\n    # The MIME type for the contents of the file located at @path\n    def mime_type path, default_mime\n      Mime.mime_type(::File.extname(path), default_mime)\n    end\n\n    def filesize path\n      # If response_body is present, use its size.\n      return response_body.bytesize if response_body\n\n      #   We check via File::size? whether this file provides size info\n      #   via stat (e.g. \/proc files often don't), otherwise we have to\n      #   figure it out by reading the whole file into memory.\n      ::File.size?(path) || ::File.read(path).bytesize\n    end\n\n    # By default, the response body for file requests is nil.\n    # In this case, the response body will be generated later\n    # from the file at @path\n    def response_body\n      nil\n    end\n  end\nend\n","pos":1,"subs":[{"rb.function":{"text":"def initialize(root, headers={}, default_mime = 'text\/plain')\n","pos":808,"subs":[{"rb.funcname":{"text":"initialize","pos":812}},{"rb.paramlist":{"text":"root, headers={}, default_mime = 'text\/plain'","pos":823,"subs":[{"rb.param":{"text":"root","pos":823}},{"rb.paramdef":{"text":"headers={}","pos":829,"subs":[{"rb.param":{"text":"headers","pos":829}},{"rb.paramval":{"text":"{}","pos":837}}]}},{"rb.paramdef":{"text":"default_mime = 'text\/plain'","pos":841,"subs":[{"rb.param":{"text":"default_mime","pos":841}},{"rb.paramval":{"text":"'text\/plain'","pos":856}}]}}]}}]}},{"rb.function":{"text":"def call(env)\n","pos":1017,"subs":[{"rb.funcname":{"text":"call","pos":1021}},{"rb.paramlist":{"text":"env","pos":1026,"subs":[{"rb.param":{"text":"env","pos":1026}}]}}]}},{"rb.function":{"text":"def get(env)\n","pos":1141,"subs":[{"rb.funcname":{"text":"get","pos":1145}},{"rb.paramlist":{"text":"env","pos":1149,"subs":[{"rb.param":{"text":"env","pos":1149}}]}}]}},{"rb.function":{"text":"def serving(request, path)\n","pos":1839,"subs":[{"rb.funcname":{"text":"serving","pos":1843}},{"rb.paramlist":{"text":"request, path","pos":1851,"subs":[{"rb.param":{"text":"request","pos":1851}},{"rb.param":{"text":"path","pos":1860}}]}}]}},{"rb.function":{"text":"def initialize path, range\n","pos":3464,"subs":[{"rb.funcname":{"text":"initialize","pos":3468}},{"rb.paramlist":{"text":" path, range","pos":3478,"subs":[{"rb.param":{"text":"path","pos":3479}},{"rb.param":{"text":"range","pos":3485}}]}}]}},{"rb.function":{"text":"def each\n","pos":3553,"subs":[{"rb.funcname":{"text":"each","pos":3557}}]}},{"rb.function":{"text":"def close;","pos":3915,"subs":[{"rb.funcname":{"text":"close","pos":3919}}]}},{"rb.function":{"text":"def make_body request, path, range\n","pos":3956,"subs":[{"rb.funcname":{"text":"make_body","pos":3960}},{"rb.paramlist":{"text":" request, path, range","pos":3969,"subs":[{"rb.param":{"text":"request","pos":3970}},{"rb.param":{"text":"path","pos":3979}},{"rb.param":{"text":"range","pos":3985}}]}}]}},{"rb.function":{"text":"def fail(status, body, headers = {})\n","pos":4092,"subs":[{"rb.funcname":{"text":"fail","pos":4096}},{"rb.paramlist":{"text":"status, body, headers = {}","pos":4101,"subs":[{"rb.param":{"text":"status","pos":4101}},{"rb.param":{"text":"body","pos":4109}},{"rb.paramdef":{"text":"headers = {}","pos":4115,"subs":[{"rb.param":{"text":"headers","pos":4115}},{"rb.paramval":{"text":"{}","pos":4125}}]}}]}}]}},{"rb.function":{"text":"def mime_type path, default_mime\n","pos":4430,"subs":[{"rb.funcname":{"text":"mime_type","pos":4434}},{"rb.paramlist":{"text":" path, default_mime","pos":4443,"subs":[{"rb.param":{"text":"path","pos":4444}},{"rb.param":{"text":"default_mime","pos":4450}}]}}]}},{"rb.function":{"text":"def filesize path\n","pos":4533,"subs":[{"rb.funcname":{"text":"filesize","pos":4537}},{"rb.paramlist":{"text":" path","pos":4545,"subs":[{"rb.param":{"text":"path","pos":4546}}]}}]}},{"rb.function":{"text":"def response_body\n","pos":5084,"subs":[{"rb.funcname":{"text":"response_body","pos":5088}}]}}]}}
