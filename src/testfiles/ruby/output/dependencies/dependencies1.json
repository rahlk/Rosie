{"rb.dependencies":{"text":"# Code sourced under MIT license from kovacs\/sortable\n\nmodule Sortable\n    def self.included(base)\n      base.extend(ClassMethods)\n    end\n\n    module ClassMethods\n      # Class method to setup a controller to create a sortable table.\n      #\n      # usage: sortable_table class_to_tabularize, optional_params\n      #\n      # simplest example possible:\n      #\n      # In your controller...\n      #\n      # sortable_table User\n      #\n      # This will create a sortable table over all your objects and display all columns.\n      # The simplest way to trim down the columns to display is to pass in a parameter specifying which columns\n      # on your object you'd like to display:\n      #\n      # sortable_table User, :display_columns => ['id', 'email', 'name', 'state', 'created_at']\n      #\n      # This will show the same sortable, searchable, paginated table with only these columns\n      #\n      # If you need a bit more control over how the objects are fetchd and displayed this is\n      # the next simplest example:\n      #\n      # Override the index action in your controller:\n      #\n      # def index\n      #  get_sorted_objects(params)\n      # end\n      #\n      # In your index action template (within the same controller) put in a helper call to show a sortable table. You can\n      # create your own table partial to be used to display the objects. See the sortable\/views\/sortable\/_table.html.erb\n      # (which is the default template used by the plugin) for an example.\n      #\n      # <%= sortable_table %>\n      #\n      # The view method will automatically generate a paginated, sortable table for the class type declared in the controller\n      #\n      # optional_params:\n      #\n      # :per_page - Number of records to show per page. Default is 10\n      #\n      # The next section deals with how to change what's displayed in the table. The first and simplest option is :display_columns.\n      # The more flexible option is to use :table_headings and :sort_map. First we'll go over the simpler option.\n      #\n      # :display_columns - Specifies which columns that you'd like to display in the table.\n      #\n      # For more flexibility you can use :table_headings and :sort_map. You would most likely use this when you want to display\n      # attributes from more than one object in the same table or if you need more flexibility with regards to sort rules.\n      # :table_headings - The table heading label and sort key. Default is all the column names for the given class\n      # :sort_map - The mapping between the sort key and the table.column to sort on. Default is all the columns for the given class\n      # :include_relations - Relations to include if you choose to display a column in a related object's table\n      #\n      # :default_sort - The default sorting column and direction when displaying the table without any sort params. Default is 'id DESC'\n      #\n      # Note: You *must* override both :table_headings and :sort_map if you do choose to override so that\n      # the contents of the column headings match up with the contents of the sort_map they associate with.\n      # Also if you override :default_sort you'll need to change the :table_headings and :sort_map if the new :default_sort\n      # column doesn't currently reside within the :table_heading and :sort_map collections\n      #\n      # Example of modifying :table_headings or :sort_map :\n      #   :table_headings => [['Name', 'name'], ['Status', 'status']]\n      #   :sort_map =>  {'name' => ['users.name'],\n      #                  'status' => ['users.status']}\n      #\n      #   Note that both 'name' and 'status' are sort keys that map to both the table heading label and the\n      #   database table.column combination that the heading refers to.\n      #\n      #   Also note that :default_sort now needs to change as well since the table no longer contains the :default_sort\n      #   column of 'id':\n      #\n      #   :default_sort => ['name', 'DESC']\n      #\n      # Example of modifying :table_headings to include a column from a related object:\n      #   :table_headings => [['Name', 'name'], ['Status', 'status'], ['Role', 'role']]\n      #   :sort_map =>  {'name' => ['users.name'],\n      #                  'status' => ['users.status'],\n      #                  'role' => ['roles.role']}\n      #\n      #   Note that we've now added 'roles.role' to the list of columns to display and sort on. In order to\n      #   make the find work properly we also need to include the related object, so we pass in the following param:\n      #   :include_relations => [:role]\n      #\n      #   Perhaps we want to sort by role ascending by default as well. We'd pass the param value:\n      #   :default_sort => ['role', 'ASC']\n      #\n      #   and the table is now sortable by a related object's column and is the default sort value for the table.\n      #\n      # Search. You can specify what columns are searchable on your objects as follows:\n      #   :search_array => ['cablecar_users.username', 'cablecar_users.name']\n      #\n      # Now search queries will only search username and name for users. By default search is enabled for all columns\n      # that are being displayed in the table. This allows you to expand or constrain those values.\n      #\n      def sortable_table_options\n        @@sortable_table_options ||={}\n      end\n\n      def sortable_table(klass, options={})\n        # sortable_table_options ||={}\n\n        sort_map = HashWithIndifferentAccess.new\n\n        if options[:table_headings] &&\n           options[:sort_map]\n           table_headings = options[:table_headings]\n           sort_map.merge!(options[:sort_map])\n        else\n          display_columns = options[:display_columns].blank? ? klass.column_names : options[:display_columns]\n          table_headings = []\n          klass.column_names.each do |att|\n            if display_columns.include?(att)\n              table_headings << [att.humanize, att]\n              sort_map[att] = [\"#{klass.table_name}.#{att}\", 'DESC']\n            end\n          end\n        end\n\n        column_procs = options[:column_procs].nil? ? {} : options[:column_procs]\n        default_sort = options[:default_sort].nil? ? [sort_map.keys.first, 'DESC'] : options[:default_sort]\n        per_page = [options[:per_page], klass.per_page, 20].compact.first\n        include_relations = options[:include_relations].nil? ? [] : options[:include_relations]\n\n        search_array = options[:search_array].nil? ? sort_map.values.collect {|v| v[0]} : options[:search_array]\n        search_type = options[:search_type].nil? ? 'MYSQL' : options[:search_type]\n        search_conditions = options[:search_conditions].nil? ? '' : options[:search_conditions]\n\n        sortable_table_options[controller_path] = {:class => klass,\n                                                     :table_headings => table_headings,\n                                                     :default_sort => default_sort,\n                                                     :sort_map => sort_map,\n                                                     :search_array => search_array,\n                                                     :search_type => search_type,\n                                                     :search_conditions => search_conditions,\n                                                     :column_procs => column_procs,\n                                                     :per_page => per_page,\n                                                     :include_relations => include_relations}\n        module_eval do\n          include Sortable::InstanceMethods\n        end\n\n      end\n    end\n\n    module InstanceMethods\n      def sortable_class\n        self.class.sortable_table_options[controller_path][:class]\n      end\n\n      def sortable_table_headings\n        self.class.sortable_table_options[controller_path][:table_headings]\n      end\n\n      def sortable_default_sort\n        self.class.sortable_table_options[controller_path][:default_sort]\n      end\n\n      def sortable_sort_map\n        self.class.sortable_table_options[controller_path][:sort_map]\n      end\n\n      def sortable_search_array\n        self.class.sortable_table_options[controller_path][:search_array]\n      end\n\n      def sortable_search_type\n        self.class.sortable_table_options[controller_path][:search_type]\n      end\n\n      def sortable_search_conditions\n        self.class.sortable_table_options[controller_path][:search_conditions]\n      end\n\n      def sortable_per_page\n        self.class.sortable_table_options[controller_path][:per_page]\n      end\n\n      def sortable_include_relations\n        self.class.sortable_table_options[controller_path][:include_relations]\n      end\n\n      def sortable_column_procs\n        self.class.sortable_table_options[controller_path][:column_procs]\n      end\n      # default impl for listing a collection of objects. Override this action in your controller to fetch objects\n      # differently and\/or to render a different template.\n      def index\n        get_sorted_objects(params)\n        render :template => 'sortable\/index'\n      end\n\n      # Users can also pass in optional conditions that are used by the finder method call. For example if only wanted to\n      # show the items that had a certain status value you could pass in a condition 'mytable.status == 300' for example\n      # as the conditions parameter and when the finder is called the sortable table will only display objects that meet those\n      # conditions. Additionally you can paginate and sort the objects that are returned and apply the conditions to them.\n      def get_sorted_objects(params, options={})\n        objects = options[:objects].nil? ? sortable_class : options[:objects]\n        include_rel = options[:include_relations].nil? ? sortable_include_relations : options[:include_relations]\n        @headings = options[:table_headings].nil? ? sortable_table_headings : options[:table_headings]\n        @column_procs = options[:sortable_column_procs].nil? ? sortable_column_procs : options[:sortable_column_procs]\n        sort_map = options[:sort_map].nil? ? sortable_sort_map : HashWithIndifferentAccess.new(options[:sort_map])\n        default_sort = options[:default_sort].nil? ? sortable_default_sort : options[:default_sort]\n        conditions = options[:conditions].nil? ? '' : options[:conditions]\n        search_array = options[:search_array].nil? ? sortable_search_array : options[:search_array]\n        search_type = options[:search_type].nil? ? sortable_search_type : options[:search_type]\n        search_conditions = options[:search_conditions].nil? ? sortable_search_conditions : options[:search_conditions]\n\n        conditions = process_search(params, conditions, {:search_array => search_array, :search_type => search_type, :search_conditions => search_conditions})\n        items_per_page = options[:per_page].nil? ? sortable_per_page : options[:per_page]\n\n        @sort_map = sort_map\n        sort = process_sort(params, sort_map, default_sort)\n        page = params[:page]\n        page ||= 1\n        # fetch the objects, paginated and sorted as desired along with any extra filtering conditions\n        get_paginated_objects(objects, sort, include_rel, conditions, page, items_per_page)\n      end\n\n      private\n      def get_paginated_objects(objects, sort, include_rel, conditions, page, items_per_page)\n        @objects = objects.paginate(:include => include_rel,\n                                 :order => sort,\n                                 :conditions => conditions,\n                                 :page => page,\n                                 :per_page => items_per_page)\n      end\n\n      # supported DB searches\n      MYSQL = 'MYSQL'\n      POSTGRES = \"POSTGRES\"\n\n      def process_search(params, conditions, options)\n        if !params[:q].blank?\n          if !options[:search_conditions].blank?\n            conditions = [conditions + \" #{options[:search_conditions]}\"] + [params[:q]]\n          else\n            search_type = options[:search_type]\n            search_array = options[:search_array]\n            search_command = search_type == POSTGRES ? 'ILIKE' : 'LIKE'\n            search_value = search_type == POSTGRES ? params[:q] : \"%#{params[:q]}%\"\n            columns_to_search = ''\n            values = Array.new\n            if search_array.size == 1\n              columns_to_search += search_array.first\n              values << search_value\n            else\n              columns_to_search = search_array.join(\" #{search_command} ? OR \")\n              search_array.size.times {|a| values << search_value}\n            end\n            columns_to_search += \" #{search_command} ? \"\n            conditions += ' and' if !conditions.blank?\n            conditions = [conditions + ' (' + columns_to_search + ')'] + values\n          end\n        end\n        return conditions\n      end\n\n      def value_provided?(params, name)\n        !params[name].nil? && !params[name].empty?\n      end\n\n      def process_sort(params, sort_map, default_sort)\n        if params['sort']\n          sort = process_sort_param(params['sort'], sort_map)\n        else\n          # fetch the table.column from the sortmap for the given sort key and append the sort direction\n          sort = sort_map[default_sort[0]][0] + ' ' + default_sort[1]\n\n          # These variables are used in the sort_link_helper and sort_td_class_helper to build the column link headings\n          # and create the proper CSS class for the column heading for the case where there is no sort param.\n          @default_sort = default_sort[0]\n          if default_sort[1] && default_sort[1] == 'DESC'\n            @default_sort_key = default_sort[0] + '_reverse'\n            @sortclass = 'sortup'\n          else\n            @default_sort_key = default_sort[0]\n            @sortclass = 'sortdown'\n          end\n        end\n        return sort\n      end\n\n      def process_sort_param(sort, sort_map)\n        mapKey = get_sort_key(sort)\n\n        if sort_map[mapKey].nil?\n          raise Exception.new(\"Invalid sort parameter passed #{sort}\")\n        end\n\n        result = ''\n        sort_array = sort_map[mapKey]\n        # this adds support for more than one sort criteria for a given column\n        # for example, status DESC, created_at ASC\n        if sort_array[0].class == Array\n          sorts = sort_array.collect {|sort_value| get_sort_direction(sort, sort_value)}\n          result = sorts.join(', ')\n        else\n          result = get_sort_direction(sort, sort_array)\n        end\n        result\n      end\n\n      def get_sort_direction(sort, sort_value)\n        result = ''\n        column = sort_value[0]\n        direction = sort_value[1] || 'ASC'\n        if \/_reverse$\/.match(sort)\n          direction = direction == 'DESC' ? 'ASC' : 'DESC'\n        end\n        result += column + ' ' + direction\n      end\n\n      def get_sort_key(sort)\n        i = sort.index('_reverse')\n        i.blank? ? sort : sort[0, i]\n      end\n    end\n\nend\n","pos":1}}
