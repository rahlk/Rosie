{"rb.strings":{"pos":1,"text":"# Copyright (C) 2007, 2008, 2009, 2010 Christian Neukirchen <purl.org\/net\/chneukirchen>\n#\n# Rack is freely distributable under the terms of an MIT-style license.\n# See COPYING or http:\/\/www.opensource.org\/licenses\/mit-license.php.\n\nrequire \"time\"\nrequire 'rack\/utils'\nload 'rack\/mime'\nload \"rack\/request\"\nrequire_relative 'rack\/head'\n\nmodule Rack\n  # Rack::File serves files below the +root+ directory given, according to the\n  # path info of the Rack request.\n  # e.g. when Rack::File.new(\"\/etc\") is used, you can access 'passwd' file\n  # as http:\/\/localhost:9292\/passwd\n  #\n  # Handlers can detect if bodies are a Rack::File, and use mechanisms\n  # like sendfile on the +path+.\n\n  class File\n    ALLOWED_VERBS = %w[GET HEAD OPTIONS]\n    ALLOW_HEADER = ALLOWED_VERBS.join(', ')\n\n    attr_reader :root\n\n    def initialize(root, headers={}, default_mime = 'text\/plain')\n      @root = root\n      @headers = headers\n      @default_mime = default_mime\n      @head = Rack::Head.new(lambda { |env| get env })\n    end\n\n    def call(env)\n      # HEAD requests drop the response body, including 4xx error messages.\n      @head.call env\n    end\n\n    def get(env)\n      request = Rack::Request.new env\n      unless ALLOWED_VERBS.include? request.request_method\n        return fail(405, \"Method Not Allowed\", {'Allow' => ALLOW_HEADER})\n      end\n\n      path_info = Utils.unescape_path request.path_info\n      return fail(400, \"Bad Request\") unless Utils.valid_path?(path_info)\n\n      clean_path_info = Utils.clean_path_info(path_info)\n      path = ::File.join(@root, clean_path_info)\n\n      available = begin\n        ::File.file?(path) && ::File.readable?(path)\n      rescue SystemCallError\n        false\n      end\n\n      if available\n        serving(request, path)\n      else\n        fail(404, \"File not found: #{path_info}\")\n      end\n    end\n\n    def serving(request, path)\n      if request.options?\n        return [200, {'Allow' => ALLOW_HEADER, CONTENT_LENGTH => '0'}, []]\n      end\n      last_modified = ::File.mtime(path).httpdate\n      return [304, {}, []] if request.get_header('HTTP_IF_MODIFIED_SINCE') == last_modified\n\n      headers = { \"Last-Modified\" => last_modified }\n      mime_type = mime_type path, @default_mime\n      headers[CONTENT_TYPE] = mime_type if mime_type\n\n      # Set custom headers\n      @headers.each { |field, content| headers[field] = content } if @headers\n\n      response = [ 200, headers ]\n\n      size = filesize path\n\n      range = nil\n      ranges = Rack::Utils.get_byte_ranges(request.get_header('HTTP_RANGE'), size)\n      if ranges.nil? || ranges.length > 1\n        # No ranges, or multiple ranges (which we don't support):\n        # TODO: Support multiple byte-ranges\n        response[0] = 200\n        range = 0..size-1\n      elsif ranges.empty?\n        # Unsatisfiable. Return error, and file size:\n        response = fail(416, \"Byte range unsatisfiable\")\n        response[1][\"Content-Range\"] = \"bytes *\/#{size}\"\n        return response\n      else\n        # Partial content:\n        range = ranges[0]\n        response[0] = 206\n        response[1][\"Content-Range\"] = \"bytes #{range.begin}-#{range.end}\/#{size}\"\n        size = range.end - range.begin + 1\n      end\n\n      response[2] = [response_body] unless response_body.nil?\n\n      response[1][CONTENT_LENGTH] = size.to_s\n      response[2] = make_body request, path, range\n      response\n    end\n\n    class Iterator\n      attr_reader :path, :range\n      alias :to_path :path\n\n      def initialize path, range\n        @path  = path\n        @range = range\n      end\n\n      def each\n        ::File.open(path, \"rb\") do |file|\n          file.seek(range.begin)\n          remaining_len = range.end-range.begin+1\n          while remaining_len > 0\n            part = file.read([8192, remaining_len].min)\n            break unless part\n            remaining_len -= part.length\n\n            yield part\n          end\n        end\n      end\n\n      def close; end\n    end\n\n    private\n\n    def make_body request, path, range\n      if request.head?\n        []\n      else\n        Iterator.new path, range\n      end\n    end\n\n    def fail(status, body, headers = {})\n      body += \"\\n\"\n\n      [\n        status,\n        {\n          CONTENT_TYPE   => \"text\/plain\",\n          CONTENT_LENGTH => body.size.to_s,\n          \"X-Cascade\" => \"pass\"\n        }.merge!(headers),\n        [body]\n      ]\n    end\n\n    # The MIME type for the contents of the file located at @path\n    def mime_type path, default_mime\n      Mime.mime_type(::File.extname(path), default_mime)\n    end\n\n    def filesize path\n      # If response_body is present, use its size.\n      return response_body.bytesize if response_body\n\n      #   We check via File::size? whether this file provides size info\n      #   via stat (e.g. \/proc files often don't), otherwise we have to\n      #   figure it out by reading the whole file into memory.\n      ::File.size?(path) || ::File.read(path).bytesize\n    end\n\n    # By default, the response body for file requests is nil.\n    # In this case, the response body will be generated later\n    # from the file at @path\n    def response_body\n      nil\n    end\n  end\nend\n","subs":[{"rb.string":{"pos":241,"text":"\"time\""}},{"rb.string":{"pos":256,"text":"'rack\/utils'"}},{"rb.string":{"pos":274,"text":"'rack\/mime'"}},{"rb.string":{"pos":291,"text":"\"rack\/request\""}},{"rb.string":{"pos":323,"text":"'rack\/head'"}},{"rb.string":{"pos":774,"text":"', '"}},{"rb.string":{"pos":856,"text":"'text\/plain'"}},{"rb.string":{"pos":1276,"text":"\"Method Not Allowed\""}},{"rb.string":{"pos":1299,"text":"'Allow'"}},{"rb.string":{"pos":1415,"text":"\"Bad Request\""}},{"rb.string":{"pos":1914,"text":"'Allow'"}},{"rb.string":{"pos":1957,"text":"'0'"}},{"rb.string":{"pos":2076,"text":"'HTTP_IF_MODIFIED_SINCE'"}},{"rb.string":{"pos":2138,"text":"\"Last-Modified\""}},{"rb.string":{"pos":2524,"text":"'HTTP_RANGE'"}},{"rb.string":{"pos":2859,"text":"\"Byte range unsatisfiable\""}},{"rb.string":{"pos":3588,"text":"\"rb\""}},{"rb.string":{"pos":4143,"text":"\"\\n\""}},{"rb.string":{"pos":4211,"text":"\"text\/plain\""}},{"rb.string":{"pos":4279,"text":"\"X-Cascade\""}},{"rb.string":{"pos":4294,"text":"\"pass\""}}]}}
