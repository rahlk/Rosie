{"cpp.functions":{"text":"\/*\n* Hacker Disassembler Engine 32 C\n* Copyright (c) 2008-2009, Vyacheslav Patkov.\n* All rights reserved.\n*\n*\/\n\n#include <stdint.h>\n#include <string.h>\n#include \"..\/include\/hde32.h\"\n#include \"..\/include\/table32.h\"\n\n#ifdef _MSC_VER\n#pragma warning(disable:4701)\n#endif\n\nunsigned int hde32_disasm(const void *code, hde32s *hs)\n{\n\tuint8_t x, c, *p = (uint8_t*)code, cflags, opcode, pref = 0;\n\tuint8_t* ht = hde32_table, m_mod, m_reg, m_rm, disp_size = 0;\n\n\tmemset(hs,0,sizeof(hde32s));\n\n\tfor (x = 16; x; x--)\n\t\tswitch (c = *p++) {\n\t\tcase 0xf3:\n\t\t\ths->p_rep = c;\n\t\t\tpref |= PRE_F3;\n\t\t\tbreak;\n\t\tcase 0xf2:\n\t\t\ths->p_rep = c;\n\t\t\tpref |= PRE_F2;\n\t\t\tbreak;\n\t\tcase 0xf0:\n\t\t\ths->p_lock = c;\n\t\t\tpref |= PRE_LOCK;\n\t\t\tbreak;\n\t\tcase 0x26: case 0x2e: case 0x36:\n\t\tcase 0x3e: case 0x64: case 0x65:\n\t\t\ths->p_seg = c;\n\t\t\tpref |= PRE_SEG;\n\t\t\tbreak;\n\t\tcase 0x66:\n\t\t\ths->p_66 = c;\n\t\t\tpref |= PRE_66;\n\t\t\tbreak;\n\t\tcase 0x67:\n\t\t\ths->p_67 = c;\n\t\t\tpref |= PRE_67;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto pref_done;\n\t}\npref_done:\n\n\ths->flags = (uint32_t)pref << 23;\n\n\tif (!pref)\n\t\tpref |= PRE_NONE;\n\n\tif ((hs->opcode = c) == 0x0f) {\n\t\ths->opcode2 = c = *p++;\n\t\tht += DELTA_OPCODES;\n\t} else if (c >= 0xa0 && c <= 0xa3) {\n\t\tif (pref & PRE_67)\n\t\t\tpref |= PRE_66;\n\t\telse\n\t\t\tpref &= ~PRE_66;\n\t}\n\n\topcode = c;\n\tcflags = ht[ht[opcode \/ 4] + (opcode % 4)];\n\n\tif (cflags == C_ERROR) {\n\t\ths->flags |= F_ERROR | F_ERROR_OPCODE;\n\t\tcflags = 0;\n\t\tif ((opcode & -3) == 0x24)\n\t\t\tcflags++;\n\t}\n\n\tx = 0;\n\tif (cflags & C_GROUP) {\n\t\tuint16_t t;\n\t\tt = *(uint16_t*)(ht + (cflags & 0x7f));\n\t\tcflags = (uint8_t)t;\n\t\tx = (uint8_t)(t >> 8);\n\t}\n\n\tif (hs->opcode2) {\n\t\tht = hde32_table + DELTA_PREFIXES;\n\t\tif (ht[ht[opcode \/ 4] + (opcode % 4)] & pref)\n\t\t\ths->flags |= F_ERROR | F_ERROR_OPCODE;\n\t}\n\n\tif (cflags & C_MODRM) {\n\t\ths->flags |= F_MODRM;\n\t\ths->modrm = c = *p++;\n\t\ths->modrm_mod = m_mod = c >> 6;\n\t\ths->modrm_rm = m_rm = c & 7;\n\t\ths->modrm_reg = m_reg = (c & 0x3f) >> 3;\n\n\t\tif (x && ((x << m_reg) & 0x80))\n\t\t\ths->flags |= F_ERROR | F_ERROR_OPCODE;\n\n\t\tif (!hs->opcode2 && opcode >= 0xd9 && opcode <= 0xdf) {\n\t\t\tuint8_t t = opcode - 0xd9;\n\t\t\tif (m_mod == 3) {\n\t\t\t\tht = hde32_table + DELTA_FPU_MODRM + t*8;\n\t\t\t\tt = ht[m_reg] << m_rm;\n\t\t\t} else {\n\t\t\t\tht = hde32_table + DELTA_FPU_REG;\n\t\t\t\tt = ht[t] << m_reg;\n\t\t\t}\n\t\t\tif (t & 0x80)\n\t\t\t\ths->flags |= F_ERROR | F_ERROR_OPCODE;\n\t\t}\n\n\t\tif (pref & PRE_LOCK) {\n\t\t\tif (m_mod == 3) {\n\t\t\t\ths->flags |= F_ERROR | F_ERROR_LOCK;\n\t\t\t} else {\n\t\t\t\tuint8_t* table_end, op = opcode;\n\t\t\t\tif (hs->opcode2) {\n\t\t\t\t\tht = hde32_table + DELTA_OP2_LOCK_OK;\n\t\t\t\t\ttable_end = ht + DELTA_OP_ONLY_MEM - DELTA_OP2_LOCK_OK;\n\t\t\t\t} else {\n\t\t\t\t\tht = hde32_table + DELTA_OP_LOCK_OK;\n\t\t\t\t\ttable_end = ht + DELTA_OP2_LOCK_OK - DELTA_OP_LOCK_OK;\n\t\t\t\t\top &= -2;\n\t\t\t\t}\n\t\t\t\tfor (; ht != table_end; ht++)\n\t\t\t\t\tif (*ht++ == op) {\n\t\t\t\t\t\tif (!((*ht << m_reg) & 0x80))\n\t\t\t\t\t\t\tgoto no_lock_error;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ths->flags |= F_ERROR | F_ERROR_LOCK;\nno_lock_error:\n\t\t\t\t\t;\n\t\t\t}\n\t\t}\n\n\t\tif (hs->opcode2) {\n\t\t\tswitch (opcode) {\n\t\t\tcase 0x20: case 0x22:\n\t\t\t\tm_mod = 3;\n\t\t\t\tif (m_reg > 4 || m_reg == 1)\n\t\t\t\t\tgoto error_operand;\n\t\t\t\telse\n\t\t\t\t\tgoto no_error_operand;\n\t\t\tcase 0x21: case 0x23:\n\t\t\t\tm_mod = 3;\n\t\t\t\tif (m_reg == 4 || m_reg == 5)\n\t\t\t\t\tgoto error_operand;\n\t\t\t\telse\n\t\t\t\t\tgoto no_error_operand;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (opcode) {\n\t\t\tcase 0x8c:\n\t\t\t\tif (m_reg > 5)\n\t\t\t\t\tgoto error_operand;\n\t\t\t\telse\n\t\t\t\t\tgoto no_error_operand;\n\t\t\tcase 0x8e:\n\t\t\t\tif (m_reg == 1 || m_reg > 5)\n\t\t\t\t\tgoto error_operand;\n\t\t\t\telse\n\t\t\t\t\tgoto no_error_operand;\n\t\t\t}\n\t\t}\n\n\t\tif (m_mod == 3) {\n\t\t\tuint8_t* table_end;\n\t\t\tif (hs->opcode2) {\n\t\t\t\tht = hde32_table + DELTA_OP2_ONLY_MEM;\n\t\t\t\ttable_end = ht + sizeof(hde32_table) - DELTA_OP2_ONLY_MEM;\n\t\t\t} else {\n\t\t\t\tht = hde32_table + DELTA_OP_ONLY_MEM;\n\t\t\t\ttable_end = ht + DELTA_OP2_ONLY_MEM - DELTA_OP_ONLY_MEM;\n\t\t\t}\n\t\t\tfor (; ht != table_end; ht += 2)\n\t\t\t\tif (*ht++ == opcode) {\n\t\t\t\t\tif ((*ht++ & pref) && !((*ht << m_reg) & 0x80))\n\t\t\t\t\t\tgoto error_operand;\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgoto no_error_operand;\n\t\t} else if (hs->opcode2) {\n\t\t\tswitch (opcode) {\n\t\t\tcase 0x50: case 0xd7: case 0xf7:\n\t\t\t\tif (pref & (PRE_NONE | PRE_66))\n\t\t\t\t\tgoto error_operand;\n\t\t\t\tbreak;\n\t\t\tcase 0xd6:\n\t\t\t\tif (pref & (PRE_F2 | PRE_F3))\n\t\t\t\t\tgoto error_operand;\n\t\t\t\tbreak;\n\t\t\tcase 0xc5:\n\t\t\t\tgoto error_operand;\n\t\t\t}\n\t\t\tgoto no_error_operand;\n\t\t} else\n\t\t\tgoto no_error_operand;\n\nerror_operand:\n\t\ths->flags |= F_ERROR | F_ERROR_OPERAND;\nno_error_operand:\n\n\t\tc = *p++;\n\t\tif (m_reg <= 1) {\n\t\t\tif (opcode == 0xf6)\n\t\t\t\tcflags |= C_IMM8;\n\t\t\telse if (opcode == 0xf7)\n\t\t\t\tcflags |= C_IMM_P66;\n\t\t}\n\n\t\tswitch (m_mod) {\n\t\tcase 0:\n\t\t\tif (pref & PRE_67) {\n\t\t\t\tif (m_rm == 6)\n\t\t\t\t\tdisp_size = 2;\n\t\t\t} else\n\t\t\t\tif (m_rm == 5)\n\t\t\t\t\tdisp_size = 4;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdisp_size = 1;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdisp_size = 2;\n\t\t\tif (!(pref & PRE_67))\n\t\t\t\tdisp_size <<= 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (m_mod != 3 && m_rm == 4 && !(pref & PRE_67)) {\n\t\t\ths->flags |= F_SIB;\n\t\t\tp++;\n\t\t\ths->sib = c;\n\t\t\ths->sib_scale = c >> 6;\n\t\t\ths->sib_index = (c & 0x3f) >> 3;\n\t\t\tif ((hs->sib_base = c & 7) == 5 && !(m_mod & 1))\n\t\t\t\tdisp_size = 4;\n\t\t}\n\n\t\tp--;\n\t\tswitch (disp_size) {\n\t\tcase 1:\n\t\t\ths->flags |= F_DISP8;\n\t\t\ths->disp.disp8 = *p;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ths->flags |= F_DISP16;\n\t\t\ths->disp.disp16 = *(uint16_t*)p;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\ths->flags |= F_DISP32;\n\t\t\ths->disp.disp32 = *(uint32_t*)p;\n\t\t\tbreak;\n\t\t}\n\t\tp += disp_size;\n\t} else if (pref & PRE_LOCK)\n\t\ths->flags |= F_ERROR | F_ERROR_LOCK;\n\n\tif (cflags & C_IMM_P66) {\n\t\tif (cflags & C_REL32) {\n\t\t\tif (pref & PRE_66) {\n\t\t\t\ths->flags |= F_IMM16 | F_RELATIVE;\n\t\t\t\ths->imm.imm16 = *(uint16_t*)p;\n\t\t\t\tp += 2;\n\t\t\t\tgoto disasm_done;\n\t\t\t}\n\t\t\tgoto rel32_ok;\n\t\t}\n\t\tif (pref & PRE_66) {\n\t\t\ths->flags |= F_IMM16;\n\t\t\ths->imm.imm16 = *(uint16_t*)p;\n\t\t\tp += 2;\n\t\t} else {\n\t\t\ths->flags |= F_IMM32;\n\t\t\ths->imm.imm32 = *(uint32_t*)p;\n\t\t\tp += 4;\n\t\t}\n\t}\n\n\tif (cflags & C_IMM16) {\n\t\tif (hs->flags & F_IMM32) {\n\t\t\ths->flags |= F_IMM16;\n\t\t\ths->disp.disp16 = *(uint16_t*)p;\n\t\t} else if (hs->flags & F_IMM16) {\n\t\t\ths->flags |= F_2IMM16;\n\t\t\ths->disp.disp16 = *(uint16_t*)p;\n\t\t} else {\n\t\t\ths->flags |= F_IMM16;\n\t\t\ths->imm.imm16 = *(uint16_t*)p;\n\t\t}\n\t\tp += 2;\n\t}\n\tif (cflags & C_IMM8) {\n\t\ths->flags |= F_IMM8;\n\t\ths->imm.imm8 = *p++;\n\t}\n\n\tif (cflags & C_REL32) {\nrel32_ok:\n\t\ths->flags |= F_IMM32 | F_RELATIVE;\n\t\ths->imm.imm32 = *(uint32_t*)p;\n\t\tp += 4;\n\t} else if (cflags & C_REL8) {\n\t\ths->flags |= F_IMM8 | F_RELATIVE;\n\t\ths->imm.imm8 = *p++;\n\t}\n\ndisasm_done:\n\n\tif ((hs->len = (uint8_t)(p-(uint8_t*)code)) > 15) {\n\t\ths->flags |= F_ERROR | F_ERROR_LENGTH;\n\t\ths->len = 15;\n\t}\n\n\treturn (unsigned int)hs->len;\n}\n","pos":1,"subs":[{"cpp.function":{"text":"endif\n\nunsigned int hde32_disasm(const void *code, hde32s *hs)\n{","pos":263,"subs":[{"cpp.return_type":{"text":"endif\n\n","pos":263}},{"cpp.function_name":{"text":"unsigned int hde32_disasm","pos":270}},{"cpp.parameters":{"text":"(const void *code, hde32s *hs)\n","pos":295,"subs":[{"cpp.single_param":{"text":"const void *code","pos":296}},{"cpp.single_param":{"text":" hde32s *hs","pos":313}}]}}]}}]}}
