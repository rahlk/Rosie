{"cpp.line_comments":{"pos":1,"subs":[{"cpp.line_comment":{"pos":3505,"subs":[{"cpp.line_comment_context":{"pos":3505,"text":"#endif "}},{"cpp.line_comment_body":{"pos":3512,"subs":[{"cpp.line_comment_text":{"pos":3514,"text":"_DEBUG"}}],"text":"\/\/_DEBUG"}}],"text":"#endif \/\/_DEBUG"}},{"cpp.line_comment":{"pos":3815,"subs":[{"cpp.line_comment_context":{"pos":3815,"text":"        "}},{"cpp.line_comment_body":{"pos":3823,"subs":[{"cpp.line_comment_text":{"pos":3825,"text":" TODO: transform insert to block of objects (do we need to transform"}}],"text":"\/\/ TODO: transform insert to block of objects (do we need to transform"}}],"text":"        \/\/ TODO: transform insert to block of objects (do we need to transform"}},{"cpp.line_comment":{"pos":3894,"subs":[{"cpp.line_comment_context":{"pos":3894,"text":"        "}},{"cpp.line_comment_body":{"pos":3902,"subs":[{"cpp.line_comment_text":{"pos":3904,"text":" coordinates according to insert point)?"}}],"text":"\/\/ coordinates according to insert point)?"}}],"text":"        \/\/ coordinates according to insert point)?"}},{"cpp.line_comment":{"pos":4554,"subs":[{"cpp.line_comment_context":{"pos":4554,"text":"#endif "}},{"cpp.line_comment_body":{"pos":4561,"subs":[{"cpp.line_comment_text":{"pos":4563,"text":"_DEBUG"}}],"text":"\/\/_DEBUG"}}],"text":"#endif \/\/_DEBUG"}},{"cpp.line_comment":{"pos":4749,"subs":[{"cpp.line_comment_context":{"pos":4749,"text":"                                                                 1].getAsLong(); "}},{"cpp.line_comment_body":{"pos":4830,"subs":[{"cpp.line_comment_text":{"pos":4832,"text":" FIXME: in 2000+ entities probably has no links to each other."}}],"text":"\/\/ FIXME: in 2000+ entities probably has no links to each other."}}],"text":"                                                                 1].getAsLong(); \/\/ FIXME: in 2000+ entities probably has no links to each other."}},{"cpp.line_comment":{"pos":4896,"subs":[{"cpp.line_comment_context":{"pos":4896,"text":"                if( dCurrentEntHandle == dLastEntHandle ) "}},{"cpp.line_comment_body":{"pos":4954,"subs":[{"cpp.line_comment_text":{"pos":4956,"text":" Blocks can be empty (contain no objects)"}}],"text":"\/\/ Blocks can be empty (contain no objects)"}}],"text":"                if( dCurrentEntHandle == dLastEntHandle ) \/\/ Blocks can be empty (contain no objects)"}},{"cpp.line_comment":{"pos":8543,"subs":[{"cpp.line_comment_context":{"pos":8543,"text":"        "}},{"cpp.line_comment_body":{"pos":8551,"subs":[{"cpp.line_comment_text":{"pos":8553,"text":" transform geometry if nHandle is in transformations"}}],"text":"\/\/ transform geometry if nHandle is in transformations"}}],"text":"        \/\/ transform geometry if nHandle is in transformations"}}],"text":"\/*******************************************************************************\n *  Project: libopencad\n *  Purpose: OpenSource CAD formats support library\n *  Author: Alexandr Borzykh, mush3d at gmail.com\n *  Author: Dmitry Baryshnikov, bishop.dev@gmail.com\n *  Language: C++\n *******************************************************************************\n *  The MIT License (MIT)\n *\n *  Copyright (c) 2016 Alexandr Borzykh\n *  Copyright (c) 2016 NextGIS, <info@nextgis.com>\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"Software\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n *******************************************************************************\/\n#include \"cadlayer.h\"\n#include \"cadfile.h\"\n\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n\nCADLayer::CADLayer( CADFile * file ) : frozen( false ), on( true ), frozenByDefault( false ), locked( false ),\n                                       plotting( false ), lineWeight( 1 ), color( 0 ), layerId( 0 ), layer_handle( 0 ),\n                                       pCADFile( file )\n{\n}\n\nstring CADLayer::getName() const\n{\n    return layerName;\n}\n\nvoid CADLayer::setName( const string& value )\n{\n    layerName = value;\n}\n\nbool CADLayer::getFrozen() const\n{\n    return frozen;\n}\n\nvoid CADLayer::setFrozen( bool value )\n{\n    frozen = value;\n}\n\nbool CADLayer::getOn() const\n{\n    return on;\n}\n\nvoid CADLayer::setOn( bool value )\n{\n    on = value;\n}\n\nbool CADLayer::getFrozenByDefault() const\n{\n    return frozenByDefault;\n}\n\nvoid CADLayer::setFrozenByDefault( bool value )\n{\n    frozenByDefault = value;\n}\n\nbool CADLayer::getLocked() const\n{\n    return locked;\n}\n\nvoid CADLayer::setLocked( bool value )\n{\n    locked = value;\n}\n\nbool CADLayer::getPlotting() const\n{\n    return plotting;\n}\n\nvoid CADLayer::setPlotting( bool value )\n{\n    plotting = value;\n}\n\nshort CADLayer::getLineWeight() const\n{\n    return lineWeight;\n}\n\nvoid CADLayer::setLineWeight( short value )\n{\n    lineWeight = value;\n}\n\nshort CADLayer::getColor() const\n{\n    return color;\n}\n\nvoid CADLayer::setColor( short value )\n{\n    color = value;\n}\n\nsize_t CADLayer::getId() const\n{\n    return layerId;\n}\n\nvoid CADLayer::setId( const size_t& value )\n{\n    layerId = value;\n}\n\nlong CADLayer::getHandle() const\n{\n    return layer_handle;\n}\n\nvoid CADLayer::setHandle( long value )\n{\n    layer_handle = value;\n}\n\nvoid CADLayer::addHandle( long handle, CADObject::ObjectType type, long cadinserthandle )\n{\n#ifdef _DEBUG\n    cout << \"addHandle: \" << handle << \" type: \" << type << endl;\n#endif \/\/_DEBUG\n    if( type == CADObject::ATTRIB || type == CADObject::ATTDEF )\n    {\n        unique_ptr<CADAttdef> attdef( static_cast< CADAttdef *>( pCADFile->GetGeometry( this->getId() - 1, handle ) ) );\n\n        attributesNames.insert( attdef->getTag() );\n    }\n\n    if( type == CADObject::INSERT )\n    {\n        \/\/ TODO: transform insert to block of objects (do we need to transform\n        \/\/ coordinates according to insert point)?\n        unique_ptr<CADObject> insert( pCADFile->GetObject( handle, false ) );\n        CADInsertObject * pInsert = static_cast<CADInsertObject *>(insert.get());\n        if( nullptr != pInsert )\n        {\n            unique_ptr<CADObject> blockHeader( pCADFile->GetObject( pInsert->hBlockHeader.getAsLong(), false ) );\n            CADBlockHeaderObject * pBlockHeader = static_cast<CADBlockHeaderObject *>(blockHeader.get());\n            if( nullptr != pBlockHeader )\n            {\n#ifdef _DEBUG\n                if( pBlockHeader->bBlkisXRef )\n                {\n                    assert( 0 );\n                }\n#endif \/\/_DEBUG\n                auto dCurrentEntHandle = pBlockHeader->hEntities[0].getAsLong();\n                auto dLastEntHandle    = pBlockHeader->hEntities[pBlockHeader->hEntities.size() -\n                                                                 1].getAsLong(); \/\/ FIXME: in 2000+ entities probably has no links to each other.\n\n                if( dCurrentEntHandle == dLastEntHandle ) \/\/ Blocks can be empty (contain no objects)\n                    return;\n\n                while( true )\n                {\n                    unique_ptr<CADEntityObject> entity( static_cast< CADEntityObject * >(\n                                                                pCADFile->GetObject( dCurrentEntHandle, true ) ) );\n\n                    if( dCurrentEntHandle == dLastEntHandle )\n                    {\n                        if( entity != nullptr )\n                        {\n                            addHandle( dCurrentEntHandle, entity->getType(), handle );\n                            Matrix mat;\n                            mat.translate( pInsert->vertInsertionPoint );\n                            mat.scale( pInsert->vertScales );\n                            mat.rotate( pInsert->dfRotation );\n                            transformations[dCurrentEntHandle] = mat;\n                            break;\n                        } else\n                        {\n                            assert( 0 );\n                        }\n                    }\n\n                    if( entity != nullptr )\n                    {\n                        addHandle( dCurrentEntHandle, entity->getType(), handle );\n                        Matrix mat;\n                        mat.translate( pInsert->vertInsertionPoint );\n                        mat.scale( pInsert->vertScales );\n                        mat.rotate( pInsert->dfRotation );\n                        transformations[dCurrentEntHandle] = mat;\n\n                        if( entity->stCed.bNoLinks )\n                            ++dCurrentEntHandle;\n                        else\n                            dCurrentEntHandle = entity->stChed.hNextEntity.getAsLong( entity->stCed.hObjectHandle );\n                    } else\n                    {\n                        assert ( 0 );\n                    }\n                }\n            }\n        }\n        return;\n    }\n\n    if( isCommonEntityType( type ) )\n    {\n        if( type == CADObject::IMAGE )\n            imageHandles.push_back( handle );\n        else\n        {\n            if( pCADFile->isReadingUnsupportedGeometries() == false )\n            {\n                if( isSupportedGeometryType( type ) )\n                {\n                    if( geometryTypes.size() == 0 ) geometryTypes.push_back( type );\n\n                    if( find( geometryTypes.begin(), geometryTypes.end(), type ) == geometryTypes.end() )\n                    {\n                        geometryTypes.push_back( type );\n                    }\n                    geometryHandles.push_back( make_pair( handle, cadinserthandle ) );\n                }\n            }\n            else\n            {\n                if( geometryTypes.size() == 0 ) geometryTypes.push_back( type );\n\n                if( find( geometryTypes.begin(), geometryTypes.end(), type ) == geometryTypes.end() )\n                {\n                    geometryTypes.push_back( type );\n                }\n                geometryHandles.push_back( make_pair( handle, cadinserthandle ) );\n            }\n        }\n    }\n}\n\nsize_t CADLayer::getGeometryCount() const\n{\n    return geometryHandles.size();\n}\n\nCADGeometry * CADLayer::getGeometry( size_t index )\n{\n    auto handleBlockRefPair = geometryHandles[index];\n    CADGeometry * pGeom = pCADFile->GetGeometry( this->getId() - 1, handleBlockRefPair.first,\n                                                 handleBlockRefPair.second );\n    if( nullptr == pGeom )\n        return nullptr;\n    auto iter = transformations.find( handleBlockRefPair.first );\n    if( iter != transformations.end() )\n    {\n        \/\/ transform geometry if nHandle is in transformations\n        pGeom->transform( iter->second );\n    }\n    return pGeom;\n}\n\nsize_t CADLayer::getImageCount() const\n{\n    return imageHandles.size();\n}\n\nCADImage * CADLayer::getImage( size_t index )\n{\n    return static_cast<CADImage *>(pCADFile->GetGeometry( this->getId() - 1, imageHandles[index] ));\n}\n\nbool CADLayer::addAttribute( const CADObject * pObject )\n{\n    if( nullptr == pObject )\n        return true;\n\n    auto      attrib = static_cast<const CADAttribObject *>(pObject);\n    for( auto i      = geometryAttributes.begin(); i != geometryAttributes.end(); ++i )\n    {\n        if( i->first == attrib->stChed.hOwner.getAsLong() )\n        {\n            i->second.insert( make_pair( attrib->sTag, layer_handle ) );\n            return true;\n        }\n    }\n\n    return false;\n}\n\nvector<CADObject::ObjectType> CADLayer::getGeometryTypes()\n{\n    return geometryTypes;\n}\n\nunordered_set<string> CADLayer::getAttributesTags()\n{\n    return attributesNames;\n}\n\n    Contact GitHub API Training Shop Blog About \n\n    © 2017 GitHub, Inc. Terms Privacy Security Status Help \n\n\n"}}
