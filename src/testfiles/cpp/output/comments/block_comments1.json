{"cpp.block_comments":{"subs":[{"cpp.block_comment":{"subs":[{"cpp.block_comment_body":{"text":"_DEBUG","pos":3517}}],"text":"\/*_DEBUG*\/","pos":3515}},{"cpp.block_comment":{"subs":[{"cpp.block_comment_body":{"text":" TODO: transform insert to block of objects (do we need to transform\n         * coordinates according to insert point)? ","pos":3830}}],"text":"\/* TODO: transform insert to block of objects (do we need to transform\n         * coordinates according to insert point)? *\/","pos":3828}},{"cpp.block_comment":{"subs":[{"cpp.block_comment_body":{"text":"_DEBUG","pos":4571}}],"text":"\/*_DEBUG*\/","pos":4569}},{"cpp.block_comment":{"subs":[{"cpp.block_comment_body":{"text":" FIXME: in 2000+ entities probably has no links to each other. ","pos":4842}}],"text":"\/* FIXME: in 2000+ entities probably has no links to each other. *\/","pos":4840}},{"cpp.block_comment":{"subs":[{"cpp.block_comment_body":{"text":" Blocks can be empty (contain no objects) ","pos":4969}}],"text":"\/* Blocks can be empty (contain no objects) *\/","pos":4967}},{"cpp.block_comment":{"subs":[{"cpp.block_comment_body":{"text":" transform geometry if nHandle is in transformations ","pos":8569}}],"text":"\/* transform geometry if nHandle is in transformations *\/","pos":8567}}],"text":"\/\/ ******************************************************************************\n\/\/  Project: libopencad\n\/\/  Purpose: OpenSource CAD formats support library\n\/\/  Author: Alexandr Borzykh, mush3d at gmail.com\n\/\/  Author: Dmitry Baryshnikov, bishop.dev@gmail.com\n\/\/  Language: C++\n\/\/ ******************************************************************************\n\/\/  The MIT License (MIT)\n\/\/\n\/\/  Copyright (c) 2016 Alexandr Borzykh\n\/\/  Copyright (c) 2016 NextGIS, <info@nextgis.com>\n\/\/\n\/\/  Permission is hereby granted, free of charge, to any person obtaining a copy\n\/\/  of this software and associated documentation files (the \"Software\"), to deal\n\/\/  in the Software without restriction, including without limitation the rights\n\/\/  to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\n\/\/  copies of the Software, and to permit persons to whom the Software is\n\/\/  furnished to do so, subject to the following conditions:\n\/\/\n\/\/  The above copyright notice and this permission notice shall be included in all\n\/\/  copies or substantial portions of the Software.\n\/\/\n\/\/  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\/\/  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\/\/  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\/\/  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\/\/  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\/\/  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\/\/  SOFTWARE.\n\/\/ ******************************************************************************\/\n#include \"cadlayer.h\"\n#include \"cadfile.h\"\n\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n\nCADLayer::CADLayer( CADFile * file ) : frozen( false ), on( true ), frozenByDefault( false ), locked( false ),\n                                       plotting( false ), lineWeight( 1 ), color( 0 ), layerId( 0 ), layer_handle( 0 ),\n                                       pCADFile( file )\n{\n}\n\nstring CADLayer::getName() const\n{\n    return layerName;\n}\n\nvoid CADLayer::setName( const string& value )\n{\n    layerName = value;\n}\n\nbool CADLayer::getFrozen() const\n{\n    return frozen;\n}\n\nvoid CADLayer::setFrozen( bool value )\n{\n    frozen = value;\n}\n\nbool CADLayer::getOn() const\n{\n    return on;\n}\n\nvoid CADLayer::setOn( bool value )\n{\n    on = value;\n}\n\nbool CADLayer::getFrozenByDefault() const\n{\n    return frozenByDefault;\n}\n\nvoid CADLayer::setFrozenByDefault( bool value )\n{\n    frozenByDefault = value;\n}\n\nbool CADLayer::getLocked() const\n{\n    return locked;\n}\n\nvoid CADLayer::setLocked( bool value )\n{\n    locked = value;\n}\n\nbool CADLayer::getPlotting() const\n{\n    return plotting;\n}\n\nvoid CADLayer::setPlotting( bool value )\n{\n    plotting = value;\n}\n\nshort CADLayer::getLineWeight() const\n{\n    return lineWeight;\n}\n\nvoid CADLayer::setLineWeight( short value )\n{\n    lineWeight = value;\n}\n\nshort CADLayer::getColor() const\n{\n    return color;\n}\n\nvoid CADLayer::setColor( short value )\n{\n    color = value;\n}\n\nsize_t CADLayer::getId() const\n{\n    return layerId;\n}\n\nvoid CADLayer::setId( const size_t& value )\n{\n    layerId = value;\n}\n\nlong CADLayer::getHandle() const\n{\n    return layer_handle;\n}\n\nvoid CADLayer::setHandle( long value )\n{\n    layer_handle = value;\n}\n\nvoid CADLayer::addHandle( long handle, CADObject::ObjectType type, long cadinserthandle )\n{\n#ifdef _DEBUG\n    cout << \"addHandle: \" << handle << \" type: \" << type << endl;\n#endif \/*_DEBUG*\/\n    if( type == CADObject::ATTRIB || type == CADObject::ATTDEF )\n    {\n        unique_ptr<CADAttdef> attdef( static_cast< CADAttdef *>( pCADFile->GetGeometry( this->getId() - 1, handle ) ) );\n\n        attributesNames.insert( attdef->getTag() );\n    }\n\n    if( type == CADObject::INSERT )\n    {\n        \/* TODO: transform insert to block of objects (do we need to transform\n         * coordinates according to insert point)? *\/\n        unique_ptr<CADObject> insert( pCADFile->GetObject( handle, false ) );\n        CADInsertObject * pInsert = static_cast<CADInsertObject *>(insert.get());\n        if( nullptr != pInsert )\n        {\n            unique_ptr<CADObject> blockHeader( pCADFile->GetObject( pInsert->hBlockHeader.getAsLong(), false ) );\n            CADBlockHeaderObject * pBlockHeader = static_cast<CADBlockHeaderObject *>(blockHeader.get());\n            if( nullptr != pBlockHeader )\n            {\n#ifdef _DEBUG\n                if( pBlockHeader->bBlkisXRef )\n                {\n                    assert( 0 );\n                }\n#endif \/*_DEBUG*\/\n                auto dCurrentEntHandle = pBlockHeader->hEntities[0].getAsLong();\n                auto dLastEntHandle    = pBlockHeader->hEntities[pBlockHeader->hEntities.size() -\n                                                                 1].getAsLong(); \/* FIXME: in 2000+ entities probably has no links to each other. *\/\n\n                if( dCurrentEntHandle == dLastEntHandle ) \/* Blocks can be empty (contain no objects) *\/\n                    return;\n\n                while( true )\n                {\n                    unique_ptr<CADEntityObject> entity( static_cast< CADEntityObject * >(\n                                                                pCADFile->GetObject( dCurrentEntHandle, true ) ) );\n\n                    if( dCurrentEntHandle == dLastEntHandle )\n                    {\n                        if( entity != nullptr )\n                        {\n                            addHandle( dCurrentEntHandle, entity->getType(), handle );\n                            Matrix mat;\n                            mat.translate( pInsert->vertInsertionPoint );\n                            mat.scale( pInsert->vertScales );\n                            mat.rotate( pInsert->dfRotation );\n                            transformations[dCurrentEntHandle] = mat;\n                            break;\n                        } else\n                        {\n                            assert( 0 );\n                        }\n                    }\n\n                    if( entity != nullptr )\n                    {\n                        addHandle( dCurrentEntHandle, entity->getType(), handle );\n                        Matrix mat;\n                        mat.translate( pInsert->vertInsertionPoint );\n                        mat.scale( pInsert->vertScales );\n                        mat.rotate( pInsert->dfRotation );\n                        transformations[dCurrentEntHandle] = mat;\n\n                        if( entity->stCed.bNoLinks )\n                            ++dCurrentEntHandle;\n                        else\n                            dCurrentEntHandle = entity->stChed.hNextEntity.getAsLong( entity->stCed.hObjectHandle );\n                    } else\n                    {\n                        assert ( 0 );\n                    }\n                }\n            }\n        }\n        return;\n    }\n\n    if( isCommonEntityType( type ) )\n    {\n        if( type == CADObject::IMAGE )\n            imageHandles.push_back( handle );\n        else\n        {\n            if( pCADFile->isReadingUnsupportedGeometries() == false )\n            {\n                if( isSupportedGeometryType( type ) )\n                {\n                    if( geometryTypes.size() == 0 ) geometryTypes.push_back( type );\n\n                    if( find( geometryTypes.begin(), geometryTypes.end(), type ) == geometryTypes.end() )\n                    {\n                        geometryTypes.push_back( type );\n                    }\n                    geometryHandles.push_back( make_pair( handle, cadinserthandle ) );\n                }\n            }\n            else\n            {\n                if( geometryTypes.size() == 0 ) geometryTypes.push_back( type );\n\n                if( find( geometryTypes.begin(), geometryTypes.end(), type ) == geometryTypes.end() )\n                {\n                    geometryTypes.push_back( type );\n                }\n                geometryHandles.push_back( make_pair( handle, cadinserthandle ) );\n            }\n        }\n    }\n}\n\nsize_t CADLayer::getGeometryCount() const\n{\n    return geometryHandles.size();\n}\n\nCADGeometry * CADLayer::getGeometry( size_t index )\n{\n    auto handleBlockRefPair = geometryHandles[index];\n    CADGeometry * pGeom = pCADFile->GetGeometry( this->getId() - 1, handleBlockRefPair.first,\n                                                 handleBlockRefPair.second );\n    if( nullptr == pGeom )\n        return nullptr;\n    auto iter = transformations.find( handleBlockRefPair.first );\n    if( iter != transformations.end() )\n    {\n        \/* transform geometry if nHandle is in transformations *\/","pos":1}}
