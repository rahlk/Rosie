{"py.dependencies":{"text":"#The MIT License (MIT)\n#\n#Copyright (c) 2017 Jordan Connor\n#\n#Permission is hereby granted, free of charge, to any person obtaining a copy\n#of this software and associated documentation files (the \"Software\"), to deal\n#in the Software without restriction, including without limitation the rights\n#to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\n#copies of the Software, and to permit persons to whom the Software is\n#furnished to do so, subject to the following conditions:\n#\n#The above copyright notice and this permission notice shall be included in\n#all copies or substantial portions of the Software.\n#\n#THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n#IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n#FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n#AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n#LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n#OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n#THE SOFTWARE.\n\nimport pandas\nimport numpy as np\nfrom bokeh.io import show\nfrom bokeh.plotting import figure\nfrom project import lattice\nfrom collections import Counter,defaultdict\nfrom multiprocessing import Process, Pipe\nfrom datetime import datetime\nfrom math import *\n\n\nQUIT = \"QUIT\"\n\nclass sim_helper(object):\n\n    def __init__(self,L,fN,u):\n        self.L = L\n        self.u = u\n        # Set our initial state\n        self.E1 = None\n        while self.E1 is None or (self.E1 < self.u[0] or self.E1 >= self.u[1]):\n            self.lat = lattice.isinglattice(L)\n            self.E1 = self.lat.E()\n\n        #Set the initial f paramater\n        self.f = np.e\n        #Define our histogram counter\n        self.H = Counter()\n        #Define our density of states and initialize to our guess\n        self.g0 = np.log(1)\n        #Define our modification paramater\n        self.fN = fN\n\n        self.G = {self.E1 : self.g0}\n\n    def sweep(self):\n        for i in range(self.L**2):\n            #Do the trial flip and calculate the new energy\n            E2 = None\n            x = None\n            y = None\n\n            x,y = np.random.randint(0,self.L,2)\n            #self.lat.flip(x,y)\n            #E2 = self.lat.E()\n            E2 = self.E1 + self.lat.dU(x, y)\n\n            if not (E2 < self.u[0] or E2 >= self.u[1]):\n                #self.lat.flip(x, y)\n\n            #else:\n                #Accept the energy if it meets the wang landau criterion\n                #or reverse the flip\n                if E2 not in self.G.keys():\n                    self.G[E2] = self.g0\n                if(np.random.uniform() <= np.exp(float(self.G[self.E1])-self.G[E2])):\n                    self.E1 = E2\n                    self.lat.flip(x, y)\n                #else:\n                    #self.lat.flip(x,y)\n\n            #update our DOS for the current energy\n            self.G[self.E1] += np.log(self.f)\n            #Add our new energy to the histogram\n            self.H[self.E1] += 1\n\n    def clear(self,f):\n        self.f = f\n        self.H.clear()\n\ndef sim_process(conn):\n    L,fN,u = conn.recv()\n    helper = sim_helper(L,fN,u)\n    while(conn.recv() != \"EOF\"):\n        for i in range(10000):\n            helper.sweep()\n        conn.send(helper.G)\n        conn.send(helper.H)\n        newF = conn.recv()\n        if(newF != helper.f):\n            helper.clear(newF)\n    conn.close()\n\nclass wanglandauising(object):\n\n    def __init__(self,L,p,fN):\n        self.L = L\n        self.p = p\n        #Define our normalized DOS\n        self.GN = {}\n        #Define an nonnormalized DOS\n        self.G = {}\n        #Define our modification factors\n        self.f = np.e\n        self.fN = fN\n        self.H = Counter()\n        self.pCount = 2\n        self.processes = []\n        self.conns = []\n        A = 2*L**2+.06\n        #self.ranges = [[-A,-A\/2.0],[-A\/2.0,0],[0,A\/2.0],[A\/2.0,A]]\n        #print(self.ranges)\n        self.ranges = [[-100,0],[0,100]]\n        #self.ranges=[[-1000,1000]]\n\n    def run(self):\n        for i in range(self.pCount):\n            parent_conn, child_conn = Pipe()\n            self.processes.append(Process(target=sim_process, args=(child_conn,)))\n            self.conns.append(parent_conn)\n            self.processes[i].start()\n            self.conns[i].send([self.L,self.fN,self.ranges[i]])\n\n\n        while not self.f < np.exp(10**-8):\n            for i in range(self.pCount):\n                self.conns[i].send(\"GO\")\n\n            for conn in self.conns:\n                for e,g in conn.recv().iteritems():\n                    self.G[e] = g\n                self.H += conn.recv()\n\n            self.check_flatness()\n\n        for i in range(self.pCount):\n            self.conns[i].send(\"EOF\")\n            self.conns[i].close()\n            self.processes[i].join()\n\n        #Normalize our DOS\n        for e,g in self.G.iteritems():\n            self.GN[e] = g - self.G[-2] + np.log(2)\n        #print(self.GN)\n\n    def check_flatness(self,a=\":)\"):\n        #Determine the average histogram\n        avgH = 0.0\n        size = 0.0\n        for e,count in self.H.iteritems():\n            avgH += count\n            size += 1.0\n        avgH = avgH\/size\n        #Now finish our average and determine our percetnage\n        avgH = avgH*self.p\n\n        #Now verify the wanglandau criterion is satisfied\n        cSat = True\n        for e,count in self.H.iteritems():\n            if count <= avgH:\n                print(str(count) + \" \" + str(avgH))\n                cSat = False\n                break\n\n        #If satisfied we reduce our modification factor\n        if cSat:\n            self.f = self.f**(1\/float(self.fN))\n            self.H.clear()\n        for conn in self.conns:\n            conn.send(self.f)\n        print(self.f)\n\n\n    def u(self,T):\n        num = 0.0\n        den = 0.0\n        for e,g in self.G.iteritems():\n            num += (e*g*np.exp(-float(e)\/T))\n            den += (g*np.exp(-float(e)\/T))\n        return (num\/den)\/self.L\n\nif __name__ == '__main__':\n    #Run the simulation\n    L = 4\n    sim = wanglandauising(L,.8,2)\n    t1 = datetime.now()\n    sim.run()\n    t2 = datetime.now()\n    delta = t2-t1\n    print(delta.microseconds)\n    #Now use the DOS to generate our energies for various values of t\n    U = []\n    G = []\n    for e,g in sim.GN.iteritems():\n        U.append(e)\n        G.append(g)\n\n    s1 = figure(width=500, plot_height=500,title=\"DOS for\" + str(L) +\" x \"+str(L)+ \"Ising Model\")\n    s1.circle(U,G,size=5,color=\"navy\",alpha=.5)\n    s1.xaxis.axis_label = \"Energy per Lattice Site\"\n    s1.yaxis.axis_label = \"ln(g(e))\"\n    show(s1)\n","subs":[{"py.dependency":{"text":"import pandas","subs":[{"py.import_module":{"text":"import pandas","subs":[{"py.module":{"text":"pandas","subs":[{"py.module_name":{"text":"pandas","pos":1110}}],"pos":1110}}],"pos":1103}}],"pos":1103}},{"py.dependency":{"text":"import numpy as np","subs":[{"py.import_module":{"text":"import numpy as np","subs":[{"py.module":{"text":"numpy as np","subs":[{"py.module_name":{"text":"numpy ","pos":1124}},{"py.module_alias":{"text":"as np","subs":[{"py.alias_name":{"text":"np","pos":1133}}],"pos":1130}}],"pos":1124}}],"pos":1117}}],"pos":1117}},{"py.dependency":{"text":"from bokeh.io import show","subs":[{"py.import_from_parent":{"text":"from bokeh.io import show","subs":[{"py.parent_module":{"text":"from bokeh.io ","subs":[{"py.parent_name":{"text":"bokeh.io ","pos":1141}}],"pos":1136}},{"py.import_module":{"text":"import show","subs":[{"py.module":{"text":"show","subs":[{"py.module_name":{"text":"show","pos":1157}}],"pos":1157}}],"pos":1150}}],"pos":1136}}],"pos":1136}},{"py.dependency":{"text":"from bokeh.plotting import figure","subs":[{"py.import_from_parent":{"text":"from bokeh.plotting import figure","subs":[{"py.parent_module":{"text":"from bokeh.plotting ","subs":[{"py.parent_name":{"text":"bokeh.plotting ","pos":1167}}],"pos":1162}},{"py.import_module":{"text":"import figure","subs":[{"py.module":{"text":"figure","subs":[{"py.module_name":{"text":"figure","pos":1189}}],"pos":1189}}],"pos":1182}}],"pos":1162}}],"pos":1162}},{"py.dependency":{"text":"from project import lattice","subs":[{"py.import_from_parent":{"text":"from project import lattice","subs":[{"py.parent_module":{"text":"from project ","subs":[{"py.parent_name":{"text":"project ","pos":1201}}],"pos":1196}},{"py.import_module":{"text":"import lattice","subs":[{"py.module":{"text":"lattice","subs":[{"py.module_name":{"text":"lattice","pos":1216}}],"pos":1216}}],"pos":1209}}],"pos":1196}}],"pos":1196}},{"py.dependency":{"text":"from collections import Counter,defaultdict","subs":[{"py.import_from_parent":{"text":"from collections import Counter,defaultdict","subs":[{"py.parent_module":{"text":"from collections ","subs":[{"py.parent_name":{"text":"collections ","pos":1229}}],"pos":1224}},{"py.import_module":{"text":"import Counter,defaultdict","subs":[{"py.module":{"text":"Counter","subs":[{"py.module_name":{"text":"Counter","pos":1248}}],"pos":1248}},{"py.module":{"text":"defaultdict","subs":[{"py.module_name":{"text":"defaultdict","pos":1256}}],"pos":1256}}],"pos":1241}}],"pos":1224}}],"pos":1224}},{"py.dependency":{"text":"from multiprocessing import Process, Pipe","subs":[{"py.import_from_parent":{"text":"from multiprocessing import Process, Pipe","subs":[{"py.parent_module":{"text":"from multiprocessing ","subs":[{"py.parent_name":{"text":"multiprocessing ","pos":1273}}],"pos":1268}},{"py.import_module":{"text":"import Process, Pipe","subs":[{"py.module":{"text":"Process","subs":[{"py.module_name":{"text":"Process","pos":1296}}],"pos":1296}},{"py.module":{"text":" Pipe","subs":[{"py.module_name":{"text":" Pipe","pos":1304}}],"pos":1304}}],"pos":1289}}],"pos":1268}}],"pos":1268}},{"py.dependency":{"text":"from datetime import datetime","subs":[{"py.import_from_parent":{"text":"from datetime import datetime","subs":[{"py.parent_module":{"text":"from datetime ","subs":[{"py.parent_name":{"text":"datetime ","pos":1315}}],"pos":1310}},{"py.import_module":{"text":"import datetime","subs":[{"py.module":{"text":"datetime","subs":[{"py.module_name":{"text":"datetime","pos":1331}}],"pos":1331}}],"pos":1324}}],"pos":1310}}],"pos":1310}},{"py.dependency":{"text":"from math import *","subs":[{"py.import_all":{"text":"from math import *","subs":[{"py.parent_module":{"text":"from math ","subs":[{"py.parent_name":{"text":"math ","pos":1345}}],"pos":1340}}],"pos":1340}}],"pos":1340}}],"pos":1}}
