{"py.functions":{"text":"#The MIT License (MIT)\n#\n#Copyright (c) 2017 Jordan Connor\n#\n#Permission is hereby granted, free of charge, to any person obtaining a copy\n#of this software and associated documentation files (the \"Software\"), to deal\n#in the Software without restriction, including without limitation the rights\n#to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\n#copies of the Software, and to permit persons to whom the Software is\n#furnished to do so, subject to the following conditions:\n#\n#The above copyright notice and this permission notice shall be included in\n#all copies or substantial portions of the Software.\n#\n#THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n#IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n#FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n#AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n#LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n#OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n#THE SOFTWARE.\n\nimport pandas\nimport numpy as np\nfrom bokeh.io import show\nfrom bokeh.plotting import figure\nfrom project import lattice\nfrom collections import Counter,defaultdict\nfrom multiprocessing import Process, Pipe\nfrom datetime import datetime\nfrom math import *\n\n\nQUIT = \"QUIT\"\n\nclass sim_helper(object):\n\n    def __init__(self,L,fN,u):\n        self.L = L\n        self.u = u\n        # Set our initial state\n        self.E1 = None\n        while self.E1 is None or (self.E1 < self.u[0] or self.E1 >= self.u[1]):\n            self.lat = lattice.isinglattice(L)\n            self.E1 = self.lat.E()\n\n        #Set the initial f paramater\n        self.f = np.e\n        #Define our histogram counter\n        self.H = Counter()\n        #Define our density of states and initialize to our guess\n        self.g0 = np.log(1)\n        #Define our modification paramater\n        self.fN = fN\n\n        self.G = {self.E1 : self.g0}\n\n    def sweep(self):\n        for i in range(self.L**2):\n            #Do the trial flip and calculate the new energy\n            E2 = None\n            x = None\n            y = None\n\n            x,y = np.random.randint(0,self.L,2)\n            #self.lat.flip(x,y)\n            #E2 = self.lat.E()\n            E2 = self.E1 + self.lat.dU(x, y)\n\n            if not (E2 < self.u[0] or E2 >= self.u[1]):\n                #self.lat.flip(x, y)\n\n            #else:\n                #Accept the energy if it meets the wang landau criterion\n                #or reverse the flip\n                if E2 not in self.G.keys():\n                    self.G[E2] = self.g0\n                if(np.random.uniform() <= np.exp(float(self.G[self.E1])-self.G[E2])):\n                    self.E1 = E2\n                    self.lat.flip(x, y)\n                #else:\n                    #self.lat.flip(x,y)\n\n            #update our DOS for the current energy\n            self.G[self.E1] += np.log(self.f)\n            #Add our new energy to the histogram\n            self.H[self.E1] += 1\n\n    def clear(self,f):\n        self.f = f\n        self.H.clear()\n\ndef sim_process(conn):\n    L,fN,u = conn.recv()\n    helper = sim_helper(L,fN,u)\n    while(conn.recv() != \"EOF\"):\n        for i in range(10000):\n            helper.sweep()\n        conn.send(helper.G)\n        conn.send(helper.H)\n        newF = conn.recv()\n        if(newF != helper.f):\n            helper.clear(newF)\n    conn.close()\n\nclass wanglandauising(object):\n\n    def __init__(self,L,p,fN):\n        self.L = L\n        self.p = p\n        #Define our normalized DOS\n        self.GN = {}\n        #Define an nonnormalized DOS\n        self.G = {}\n        #Define our modification factors\n        self.f = np.e\n        self.fN = fN\n        self.H = Counter()\n        self.pCount = 2\n        self.processes = []\n        self.conns = []\n        A = 2*L**2+.06\n        #self.ranges = [[-A,-A\/2.0],[-A\/2.0,0],[0,A\/2.0],[A\/2.0,A]]\n        #print(self.ranges)\n        self.ranges = [[-100,0],[0,100]]\n        #self.ranges=[[-1000,1000]]\n\n    def run(self):\n        for i in range(self.pCount):\n            parent_conn, child_conn = Pipe()\n            self.processes.append(Process(target=sim_process, args=(child_conn,)))\n            self.conns.append(parent_conn)\n            self.processes[i].start()\n            self.conns[i].send([self.L,self.fN,self.ranges[i]])\n\n\n        while not self.f < np.exp(10**-8):\n            for i in range(self.pCount):\n                self.conns[i].send(\"GO\")\n\n            for conn in self.conns:\n                for e,g in conn.recv().iteritems():\n                    self.G[e] = g\n                self.H += conn.recv()\n\n            self.check_flatness()\n\n        for i in range(self.pCount):\n            self.conns[i].send(\"EOF\")\n            self.conns[i].close()\n            self.processes[i].join()\n\n        #Normalize our DOS\n        for e,g in self.G.iteritems():\n            self.GN[e] = g - self.G[-2] + np.log(2)\n        #print(self.GN)\n\n    def check_flatness(self,a=\":)\"):\n        #Determine the average histogram\n        avgH = 0.0\n        size = 0.0\n        for e,count in self.H.iteritems():\n            avgH += count\n            size += 1.0\n        avgH = avgH\/size\n        #Now finish our average and determine our percetnage\n        avgH = avgH*self.p\n\n        #Now verify the wanglandau criterion is satisfied\n        cSat = True\n        for e,count in self.H.iteritems():\n            if count <= avgH:\n                print(str(count) + \" \" + str(avgH))\n                cSat = False\n                break\n\n        #If satisfied we reduce our modification factor\n        if cSat:\n            self.f = self.f**(1\/float(self.fN))\n            self.H.clear()\n        for conn in self.conns:\n            conn.send(self.f)\n        print(self.f)\n\n\n    def u(self,T):\n        num = 0.0\n        den = 0.0\n        for e,g in self.G.iteritems():\n            num += (e*g*np.exp(-float(e)\/T))\n            den += (g*np.exp(-float(e)\/T))\n        return (num\/den)\/self.L\n\nif __name__ == '__main__':\n    #Run the simulation\n    L = 4\n    sim = wanglandauising(L,.8,2)\n    t1 = datetime.now()\n    sim.run()\n    t2 = datetime.now()\n    delta = t2-t1\n    print(delta.microseconds)\n    #Now use the DOS to generate our energies for various values of t\n    U = []\n    G = []\n    for e,g in sim.GN.iteritems():\n        U.append(e)\n        G.append(g)\n\n    s1 = figure(width=500, plot_height=500,title=\"DOS for\" + str(L) +\" x \"+str(L)+ \"Ising Model\")\n    s1.circle(U,G,size=5,color=\"navy\",alpha=.5)\n    s1.xaxis.axis_label = \"Energy per Lattice Site\"\n    s1.yaxis.axis_label = \"ln(g(e))\"\n    show(s1)\n","subs":[{"py.function":{"text":"def __init__(self,L,fN,u):","subs":[{"py.function_name":{"text":"__init__","pos":1411}},{"py.paramaters":{"text":"self,L,fN,u","pos":1420}}],"pos":1407}},{"py.function":{"text":"def sweep(self):","subs":[{"py.function_name":{"text":"sweep","pos":2019}},{"py.paramaters":{"text":"self","pos":2025}}],"pos":2015}},{"py.function":{"text":"def clear(self,f):","subs":[{"py.function_name":{"text":"clear","pos":3068}},{"py.paramaters":{"text":"self,f","pos":3074}}],"pos":3064}},{"py.function":{"text":"def sim_process(conn):","subs":[{"py.function_name":{"text":"sim_process","pos":3130}},{"py.paramaters":{"text":"conn","pos":3142}}],"pos":3126}},{"py.function":{"text":"def __init__(self,L,p,fN):","subs":[{"py.function_name":{"text":"__init__","pos":3499}},{"py.paramaters":{"text":"self,L,p,fN","pos":3508}}],"pos":3495}},{"py.function":{"text":"def run(self):","subs":[{"py.function_name":{"text":"run","pos":4065}},{"py.paramaters":{"text":"self","pos":4069}}],"pos":4061}},{"py.function":{"text":"def check_flatness(self,a=\":)\"):","subs":[{"py.function_name":{"text":"check_flatness","pos":5008}},{"py.paramaters":{"text":"self,a=\":)\"","pos":5023}}],"pos":5004}},{"py.function":{"text":"def u(self,T):","subs":[{"py.function_name":{"text":"u","pos":5820}},{"py.paramaters":{"text":"self,T","pos":5822}}],"pos":5816}}],"pos":1}}
