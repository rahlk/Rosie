{"java.dependencies":{"subs":[{"java.package":{"subs":[{"java.package_text":{"text":"jenkins.security","pos":1152}}],"text":"package jenkins.security","pos":1144}},{"java.dependency":{"subs":[{"java.dependency_text":{"text":"hudson.Extension","pos":1178}}],"text":"import hudson.Extension","pos":1171}},{"java.dependency":{"subs":[{"java.dependency_text":{"text":"jenkins.util.SystemProperties","pos":1206}}],"text":"import    jenkins.util.SystemProperties","pos":1196}},{"java.dependency":{"subs":[{"java.dependency_text":{"text":"hudson.Util","pos":1244}}],"text":"import hudson.Util  ","pos":1237}},{"java.dependency":{"subs":[{"java.dependency_text":{"text":"hudson.model.Descriptor.FormException","pos":1266}}],"text":"import hudson.model.Descriptor.FormException","pos":1259}},{"java.dependency":{"subs":[{"java.dependency_text":{"text":"hudson.model.User","pos":1312}}],"text":"import hudson.model.User","pos":1305}},{"java.dependency":{"subs":[{"java.dependency_text":{"text":"hudson.model.UserProperty","pos":1338}}],"text":"import hudson.model.UserProperty","pos":1331}},{"java.dependency":{"subs":[{"java.dependency_text":{"text":"hudson.model.UserPropertyDescriptor","pos":1372}}],"text":"import hudson.model.UserPropertyDescriptor","pos":1365}},{"java.dependency":{"subs":[{"java.dependency_text":{"text":"hudson.security.ACL","pos":1416}}],"text":"import hudson.security.ACL","pos":1409}},{"java.dependency":{"subs":[{"java.dependency_text":{"text":"hudson.util.HttpResponses","pos":1444}}],"text":"import hudson.util.HttpResponses","pos":1437}},{"java.dependency":{"subs":[{"java.dependency_text":{"text":"hudson.util.Secret","pos":1478}}],"text":"import hudson.util.Secret","pos":1471}},{"java.dependency":{"subs":[{"java.dependency_text":{"text":"jenkins.model.Jenkins","pos":1505}}],"text":"import jenkins.model.Jenkins","pos":1498}},{"java.dependency":{"subs":[{"java.dependency_text":{"text":"net.sf.json.JSONObject","pos":1535}}],"text":"import net.sf.json.JSONObject","pos":1528}},{"java.dependency":{"subs":[{"java.dependency_text":{"text":"org.jenkinsci.Symbol","pos":1566}}],"text":"import org.jenkinsci.Symbol","pos":1559}},{"java.dependency":{"subs":[{"java.dependency_text":{"text":"org.kohsuke.stapler.AncestorInPath","pos":1595}}],"text":"import org.kohsuke.stapler.AncestorInPath","pos":1588}},{"java.dependency":{"subs":[{"java.dependency_text":{"text":"org.kohsuke.stapler.DataBoundConstructor","pos":1638}}],"text":"import org.kohsuke.stapler.DataBoundConstructor","pos":1631}},{"java.dependency":{"subs":[{"java.dependency_text":{"text":"org.kohsuke.stapler.HttpResponse","pos":1687}}],"text":"import org.kohsuke.stapler.HttpResponse","pos":1680}},{"java.dependency":{"subs":[{"java.dependency_text":{"text":"org.kohsuke.stapler.StaplerRequest","pos":1728}}],"text":"import org.kohsuke.stapler.StaplerRequest","pos":1721}},{"java.dependency":{"subs":[{"java.dependency_text":{"text":"org.kohsuke.stapler.StaplerResponse","pos":1771}}],"text":"import org.kohsuke.stapler.StaplerResponse","pos":1764}},{"java.dependency":{"subs":[{"java.dependency_text":{"text":"java.io.IOException","pos":1816}}],"text":"import java.io.IOException","pos":1809}},{"java.dependency":{"subs":[{"java.dependency_text":{"text":"java.nio.charset.Charset","pos":1844}}],"text":"import java.nio.charset.Charset","pos":1837}},{"java.dependency":{"subs":[{"java.dependency_text":{"text":"java.security.MessageDigest","pos":1877}}],"text":"import java.security.MessageDigest","pos":1870}},{"java.dependency":{"subs":[{"java.dependency_text":{"text":"java.security.SecureRandom","pos":1913}}],"text":"import java.security.SecureRandom","pos":1906}},{"java.dependency":{"subs":[{"java.dependency_text":{"text":"javax.annotation.Nonnull","pos":1948}}],"text":"import javax.annotation.Nonnull","pos":1941}},{"java.dependency":{"subs":[{"java.dependency_text":{"text":"org.apache.commons.lang.StringUtils","pos":1980}}],"text":"import org.apache.commons.lang.StringUtils","pos":1973}},{"java.dependency":{"subs":[{"java.dependency_text":{"text":"org.kohsuke.accmod.Restricted","pos":2023}}],"text":"import org.kohsuke.accmod.Restricted","pos":2016}},{"java.dependency":{"subs":[{"java.dependency_text":{"text":"org.kohsuke.accmod.restrictions.NoExternalUse","pos":2061}}],"text":"import org.kohsuke.accmod.restrictions.NoExternalUse","pos":2054}},{"java.dependency":{"subs":[{"java.static":{"text":"static ","pos":2116}},{"java.dependency_text":{"text":"com.google.common.base.Preconditions.*","pos":2123}}],"text":"import static com.google.common.base.Preconditions.*","pos":2109}}],"text":"\/*\n * The MIT License\n *\n * Copyright (c) 2011, CloudBees, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\/\npackage jenkins.security;\n\nimport hudson.Extension;\nimport    jenkins.util.SystemProperties;\nimport hudson.Util  ;\nimport hudson.model.Descriptor.FormException;\nimport hudson.model.User;\nimport hudson.model.UserProperty;\nimport hudson.model.UserPropertyDescriptor;\nimport hudson.security.ACL;\nimport hudson.util.HttpResponses;\nimport hudson.util.Secret;\nimport jenkins.model.Jenkins;\nimport net.sf.json.JSONObject;\nimport org.jenkinsci.Symbol;\nimport org.kohsuke.stapler.AncestorInPath;\nimport org.kohsuke.stapler.DataBoundConstructor;\nimport org.kohsuke.stapler.HttpResponse;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\n\nimport java.io.IOException;\nimport java.nio.charset.Charset;\nimport java.security.MessageDigest;\nimport java.security.SecureRandom;\nimport javax.annotation.Nonnull;import org.apache.commons.lang.StringUtils;import org.kohsuke.accmod.Restricted;\nimport org.kohsuke.accmod.restrictions.NoExternalUse;\n\nimport static com.google.common.base.Preconditions.*;\n\n\/**\n * Remembers the API token for this user, that can be used like a password to login.\n *\n *\n * @author Kohsuke Kawaguchi\n * @see ApiTokenFilter\n * @since 1.426\n *\/\npublic class ApiTokenProperty extends UserProperty {\n    private volatile Secret apiToken;\n    private String test1 = \"http:\/\/8080:localhost\";\n    private String test2 = \"http:\/\/8080:localhost\";\/\/This comment should be extracted\n\n    \/**\n     * If enabled, shows API tokens to users with {@link Jenkins#ADMINISTER) permissions.\n     * Disabled by default due to the security reasons.\n     * If enabled, it restores the original Jenkins behavior (SECURITY-200).\n     * @since 1.638\n     *\/\n    private static final boolean SHOW_TOKEN_TO_ADMINS =\n            SystemProperties.getBoolean(ApiTokenProperty.class.getName() + \".showTokenToAdmins\");\n\n\n    @DataBoundConstructor\n    public ApiTokenProperty() {\n        _changeApiToken();\n    }\n\n    \/**\n     * We don't let the external code set the API token,\n     * but for the initial value of the token we need to compute the seed by ourselves.\n     *\/\n    \/*package*\/ ApiTokenProperty(String seed) {\n        apiToken = Secret.fromString(seed);\n    }\n\n    \/**\n     * Gets the API token.\n     * The method performs security checks since 1.638. Only the current user and SYSTEM may see it.\n     * Users with {@link Jenkins#ADMINISTER} may be allowed to do it using {@link #SHOW_TOKEN_TO_ADMINS}.\n     *\n     * @return API Token. Never null, but may be {@link Messages#ApiTokenProperty_ChangeToken_TokenIsHidden()}\n     *         if the user has no appropriate permissions.\n     * @since 1.426, and since 1.638 the method performs security checks\n     *\/\n    @Nonnull\n    public String getApiToken() {\n        return hasPermissionToSeeToken() ? getApiTokenInsecure()\n                : Messages.ApiTokenProperty_ChangeToken_TokenIsHidden();\n    }\n\n    @Nonnull\n    @Restricted(NoExternalUse.class)\n    \/*package*\/ String getApiTokenInsecure() {\n        String p = apiToken.getPlainText();\n        if (p.equals(Util.getDigestOf(Jenkins.getInstance().getSecretKey()+\":\"+user.getId()))) {\n            \/\/ if the current token is the initial value created by pre SECURITY-49 Jenkins, we can't use that.\n            \/\/ force using the newer value\n            apiToken = Secret.fromString(p=API_KEY_SEED.mac(user.getId()));\n        }\n        return Util.getDigestOf(p);\n    }\n\n    public boolean matchesPassword(String password) {\n        String token = getApiTokenInsecure();\n        \/\/ String.equals isn't constant time, but this is\n        return MessageDigest.isEqual(password.getBytes(Charset.forName(\"US-ASCII\")),\n                token.getBytes(Charset.forName(\"US-ASCII\")));\n    }\n\n    private boolean hasPermissionToSeeToken() {\n        final Jenkins jenkins = Jenkins.getInstance();\n\n        \/\/ Administrators can do whatever they want\n        if (SHOW_TOKEN_TO_ADMINS && jenkins.hasPermission(Jenkins.ADMINISTER)) {\n            return true;\n        }\n\n\n        final User current = User.current();\n        if (current == null) { \/\/ Anonymous\n            return false;\n        }\n\n        \/\/ SYSTEM user is always eligible to see tokens\n        if (Jenkins.getAuthentication() == ACL.SYSTEM) {\n            return true;\n        }\n\n        \/\/TODO: replace by IdStrategy in newer Jenkins versions\n        \/\/return User.idStrategy().equals(user.getId(), current.getId());\n        return StringUtils.equals(user.getId(), current.getId());\n    }\n\n    public void changeApiToken() throws IOException {\n        user.checkPermission(Jenkins.ADMINISTER);\n        _changeApiToken();\n        user.save();\n    }\n\n    private void _changeApiToken() {\n        byte[] random = new byte[16];   \/\/ 16x8=128bit worth of randomness, since we use md5 digest as the API token\n        RANDOM.nextBytes(random);\n        apiToken = Secret.fromString(Util.toHexString(random));\n    }\n\n    @Override\n    public UserProperty reconfigure(StaplerRequest req, JSONObject form) throws FormException {\n        return this;\n    }\n\n    @Extension @Symbol(\"apiToken\")\n    public static final class DescriptorImpl extends UserPropertyDescriptor {\n        public String getDisplayName() {\n            return Messages.ApiTokenProperty_DisplayName();\n        }\n\n        \/**\n         * When we are creating a default {@link ApiTokenProperty} for User,\n         * we need to make sure it yields the same value for the same user,\n         * because there's no guarantee that the property is saved.\n         *\n         * But we also need to make sure that an attacker won't be able to guess\n         * the initial API token value. So we take the seed by hashing the secret + user ID.\n         *\/\n        public ApiTokenProperty newInstance(User user) {\n            return new ApiTokenProperty(API_KEY_SEED.mac(user.getId()));\n        }\n\n        public HttpResponse doChangeToken(@AncestorInPath User u, StaplerResponse rsp) throws IOException {\n            ApiTokenProperty p = u.getProperty(ApiTokenProperty.class);\n            if (p==null) {\n                p = newInstance(u);\n                u.addProperty(p);\n            } else {\n                p.changeApiToken();\n            }\n            rsp.setHeader(\"script\",\"document.getElementById('apiToken').value='\"+p.getApiToken()+\"'\");\n            return HttpResponses.html(p.hasPermissionToSeeToken()\n                    ? Messages.ApiTokenProperty_ChangeToken_Success()\n                    : Messages.ApiTokenProperty_ChangeToken_SuccessHidden());\n        }\n    }\n\n    private static final SecureRandom RANDOM = new SecureRandom();\n\n    \/**\n     * We don't want an API key that's too long, so cut the length to 16 (which produces 32-letter MAC code in hexdump)\n     *\/\n    private static final HMACConfidentialKey API_KEY_SEED = new HMACConfidentialKey(ApiTokenProperty.class,\"seed\",16);\n}\n","pos":1}}
