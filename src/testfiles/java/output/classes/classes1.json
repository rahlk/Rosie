{"java.classes":{"subs":[{"java.class":{"subs":[{"java.access_sp":{"pos":1615,"text":"public "}},{"java.class_name":{"pos":1628,"text":"HoloCircularProgressBar"}},{"java.hierarchy":{"subs":[{"java.parent_name":{"pos":1660,"text":"View"}}],"pos":1651,"text":" extends View"}}],"pos":1614,"text":"\npublic class HoloCircularProgressBar extends View"}}],"pos":1,"text":"\/**\nCopyright (C) 2013, Johannes Bjerva\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*\/\npackage de.passsy.holocircularprogressbar;\n\nimport android.annotation.SuppressLint;\nimport android.content.Context;\nimport android.content.res.TypedArray;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Paint;\nimport android.graphics.RectF;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Parcelable;\nimport android.util.AttributeSet;\nimport android.view.Gravity;\nimport android.view.View;\n\n\/**\n * The Class HoloCircularProgressBar.\n * \n * @author Pascal.Welsch\n * @since 05.03.2013\n *\/\npublic class HoloCircularProgressBar extends View {\n\n\t\/**\n\t * The Constant TAG.\n\t *\/\n\tprivate static final String TAG = \"CircularProgressBar\";\n\n\t\/**\n\t * used to save the super state on configuration change\n\t *\/\n\tprivate static final String INSTNACE_STATE_SAVEDSTATE = \"saved_state\";\n\n\t\/**\n\t * used to save the progress on configuration changes\n\t *\/\n\tprivate static final String INSTNACE_STATE_PROGRESS = \"progress\";\n\n\t\/**\n\t * used to save the marker progress on configuration changes\n\t *\/\n\tprivate static final String INSTNACE_STATE_MARKER_PROGRESS = \"marker_progress\";\n\n\t\/**\n\t * true if not all properties are set. then the view isn't drawn and there\n\t * are no errors in the LayoutEditor\n\t *\/\n\tprivate boolean mIsInitializing = true;\n\n\t\/**\n\t * the paint for the background.\n\t *\/\n\tprivate Paint mBackgroundColorPaint = new Paint();\n\n\t\/**\n\t * The stroke width used to paint the circle.\n\t *\/\n\tprivate int mCircleStrokeWidth = 10;\n\n\t\/**\n\t * The pointer width (in pixels).\n\t *\/\n\tprivate int mThumbRadius = 20;\n\n\t\/**\n\t * The rectangle enclosing the circle.\n\t *\/\n\tprivate final RectF mCircleBounds = new RectF();\n\n\t\/**\n\t * Radius of the circle\n\t * \n\t * <p>\n\t * Note: (Re)calculated in {@link #onMeasure(int, int)}.\n\t * <\/p>\n\t *\/\n\tprivate float mRadius;\n\n\t\/**\n\t * the color of the progress.\n\t *\/\n\tprivate int mProgressColor;\n\n\t\/**\n\t * paint for the progress.\n\t *\/\n\tprivate final Paint mProgressColorPaint;\n\n\t\/**\n\t * The color of the progress background.\n\t *\/\n\tprivate int mProgressBackgroundColor;\n\n\t\/**\n\t * The current progress.\n\t *\/\n\tprivate float mProgress = 0.3f;\n\n\t\/**\n\t * The Thumb color paint.\n\t *\/\n\tprivate Paint mThumbColorPaint = new Paint();\n\n\t\/**\n\t * The Marker progress.\n\t *\/\n\tprivate float mMarkerProgress = 0.0f;\n\n\t\/**\n\t * The Marker color paint.\n\t *\/\n\tprivate final Paint mMarkerColorPaint;\n\n\t\/**\n\t * flag if the marker should be visible\n\t *\/\n\tprivate boolean mIsMarkerEnabled = false;\n\n\t\/**\n\t * The gravity of the view. Where should the Circle be drawn within the\n\t * given bounds\n\t * \n\t * {@link #computeInsets(int, int)}\n\t *\/\n\tprivate final int mGravity;\n\n\t\/**\n\t * The Horizontal inset calcualted in {@link #computeInsets(int, int)}\n\t * depends on {@link #mGravity}.\n\t *\/\n\tprivate int mHorizontalInset = 0;\n\n\t\/**\n\t * The Vertical inset calcualted in {@link #computeInsets(int, int)} depends\n\t * on {@link #mGravity}..\n\t *\/\n\tprivate int mVerticalInset = 0;\n\n\t\/**\n\t * The Translation offset x which gives us the ability to use our own\n\t * coordinates system.\n\t *\/\n\tprivate float mTranslationOffsetX;\n\n\t\/**\n\t * The Translation offset y which gives us the ability to use our own\n\t * coordinates system.\n\t *\/\n\tprivate float mTranslationOffsetY;\n\n\t\/**\n\t * The Thumb pos x.\n\t * \n\t * Care. the position is not the position of the rotated thumb. The position\n\t * is only calculated in {@link #onMeasure(int, int)}\n\t *\/\n\tprivate float mThumbPosX;\n\n\t\/**\n\t * The Thumb pos y.\n\t * \n\t * Care. the position is not the position of the rotated thumb. The position\n\t * is only calculated in {@link #onMeasure(int, int)}\n\t *\/\n\tprivate float mThumbPosY;\n\n\t\/**\n\t * the overdraw is true if the progress is over 1.0.\n\t * \n\t *\/\n\tprivate boolean mOverrdraw = false;\n\n\t\/**\n\t * Instantiates a new holo circular progress bar.\n\t * \n\t * @param context\n\t *            the context\n\t *\/\n\tpublic HoloCircularProgressBar(final Context context) {\n\t\tthis(context, null);\n\t}\n\n\t\/**\n\t * Instantiates a new holo circular progress bar.\n\t * \n\t * @param context\n\t *            the context\n\t * @param attrs\n\t *            the attrs\n\t *\/\n\tpublic HoloCircularProgressBar(final Context context,\n\t\t\tfinal AttributeSet attrs) {\n\t\tthis(context, attrs, R.attr.circularProgressBarStyle);\n\t}\n\n\t\/**\n\t * Instantiates a new holo circular progress bar.\n\t * \n\t * @param context\n\t *            the context\n\t * @param attrs\n\t *            the attrs\n\t * @param defStyle\n\t *            the def style\n\t *\/\n\tpublic HoloCircularProgressBar(final Context context,\n\t\t\tfinal AttributeSet attrs, final int defStyle) {\n\t\tsuper(context, attrs, defStyle);\n\n\t\t\/\/ load the styled attributes and set their properties\n\t\tfinal TypedArray attributes = context.obtainStyledAttributes(attrs,\n\t\t\t\tR.styleable.HoloCircularProgressBar, defStyle, 0);\n\n\t\tsetProgressColor(attributes.getColor(\n\t\t\t\tR.styleable.HoloCircularProgressBar_progress_color, Color.CYAN));\n\t\tsetProgressBackgroundColor(attributes.getColor(\n\t\t\t\tR.styleable.HoloCircularProgressBar_progress_background_color,\n\t\t\t\tColor.MAGENTA));\n\t\tsetProgress(attributes.getFloat(\n\t\t\t\tR.styleable.HoloCircularProgressBar_progress, 0.0f));\n\t\tsetMarkerProgress(attributes.getFloat(\n\t\t\t\tR.styleable.HoloCircularProgressBar_marker_progress, 0.0f));\n\t\tsetWheelSize((int) attributes.getDimension(\n\t\t\t\tR.styleable.HoloCircularProgressBar_stroke_width, 10));\n\t\tmGravity = attributes.getInt(\n\t\t\t\tR.styleable.HoloCircularProgressBar_gravity, Gravity.CENTER);\n\n\t\tattributes.recycle();\n\n\t\tmThumbRadius = mCircleStrokeWidth * 2;\n\n\t\tmBackgroundColorPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n\t\tmBackgroundColorPaint.setColor(mProgressBackgroundColor);\n\t\tmBackgroundColorPaint.setStyle(Paint.Style.STROKE);\n\t\tmBackgroundColorPaint.setStrokeWidth(mCircleStrokeWidth);\n\n\t\tmMarkerColorPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n\t\tmMarkerColorPaint.setColor(mProgressBackgroundColor);\n\t\tmMarkerColorPaint.setStyle(Paint.Style.STROKE);\n\t\tmMarkerColorPaint.setStrokeWidth(mCircleStrokeWidth \/ 2);\n\n\t\tmProgressColorPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n\t\tmProgressColorPaint.setColor(mProgressColor);\n\t\tmProgressColorPaint.setStyle(Paint.Style.STROKE);\n\t\tmProgressColorPaint.setStrokeWidth(mCircleStrokeWidth);\n\n\t\tmThumbColorPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n\t\tmThumbColorPaint.setColor(mProgressColor);\n\t\tmThumbColorPaint.setStyle(Paint.Style.FILL_AND_STROKE);\n\t\tmThumbColorPaint.setStrokeWidth(mCircleStrokeWidth);\n\n\t\t\/\/ the view has now all properties and can be drawn\n\t\tmIsInitializing = false;\n\n\t}\n\n\t\/**\n\t * @param dx\n\t *            the dx the horizontal unfilled space\n\t * @param dy\n\t *            the dy the horizontal unfilled space\n\t *\/\n\t@SuppressLint(\"NewApi\")\n\tprivate void computeInsets(final int dx, final int dy) {\n\t\tfinal int layoutDirection;\n\t\tint absoluteGravity = mGravity;\n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {\n\t\t\tlayoutDirection = getLayoutDirection();\n\t\t\tabsoluteGravity = Gravity.getAbsoluteGravity(mGravity,\n\t\t\t\t\tlayoutDirection);\n\t\t}\n\n\t\tswitch (absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {\n\t\tcase Gravity.LEFT:\n\t\t\tmHorizontalInset = 0;\n\t\t\tbreak;\n\t\tcase Gravity.RIGHT:\n\t\t\tmHorizontalInset = dx;\n\t\t\tbreak;\n\t\tcase Gravity.CENTER_HORIZONTAL:\n\t\tdefault:\n\t\t\tmHorizontalInset = dx \/ 2;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (absoluteGravity & Gravity.VERTICAL_GRAVITY_MASK) {\n\t\tcase Gravity.TOP:\n\t\t\tmVerticalInset = 0;\n\t\t\tbreak;\n\t\tcase Gravity.BOTTOM:\n\t\t\tmVerticalInset = dy;\n\t\t\tbreak;\n\t\tcase Gravity.CENTER_VERTICAL:\n\t\tdefault:\n\t\t\tmVerticalInset = dy \/ 2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t\/**\n\t * Gets the current rotation.\n\t * \n\t * @return the current rotation\n\t *\/\n\tprivate float getCurrentRotation() {\n\t\treturn 360 * mProgress;\n\t}\n\n\tpublic float getMarkerProgress() {\n\t\treturn mMarkerProgress;\n\t}\n\n\t\/**\n\t * Gets the marker rotation.\n\t * \n\t * @return the marker rotation\n\t *\/\n\tprivate float getMarkerRotation() {\n\n\t\treturn 360 * mMarkerProgress;\n\t}\n\n\tpublic float getProgress() {\n\t\treturn mProgress;\n\t}\n\n\t\/**\n\t * Gets the progress color.\n\t * \n\t * @return the progress color\n\t *\/\n\tpublic int getProgressColor() {\n\t\treturn mProgressColor;\n\t}\n\n\t\/*\n\t * (non-Javadoc)\n\t * \n\t * @see android.view.View#onDraw(android.graphics.Canvas)\n\t *\/\n\t@Override\n\tprotected void onDraw(final Canvas canvas) {\n\n\t\t\/\/ All of our positions are using our internal coordinate system.\n\t\t\/\/ Instead of translating\n\t\t\/\/ them we let Canvas do the work for us.\n\n\t\t\/\/ Adjust by -0.8 to compensate for faulty image\n\t\tcanvas.translate(mTranslationOffsetX - 0.8f, mTranslationOffsetY - 0.8f);\n\n\t\tfinal float progressRotation = getCurrentRotation();\n\n\t\t\/\/ draw the background\n\t\tif (!mOverrdraw) {\n\t\t\tcanvas.drawArc(mCircleBounds, 270, -(360 - progressRotation),\n\t\t\t\t\tfalse, mBackgroundColorPaint);\n\t\t}\n\n\t\t\/\/ draw the progress or a full circle if overdraw is true\n\t\tcanvas.drawArc(mCircleBounds, 270, mOverrdraw ? 360 : progressRotation,\n\t\t\t\tfalse, mProgressColorPaint);\n\n\t\t\/\/ draw the marker at the correct rotated position\n\t\tif (mIsMarkerEnabled) {\n\t\t\t\/*\n\t\t\t * final float markerRotation = getMarkerRotation();\n\t\t\t * \n\t\t\t * canvas.save(); canvas.rotate(markerRotation - 90);\n\t\t\t * canvas.drawLine((float) (mThumbPosX + mThumbRadius \/ 2 * 1.4),\n\t\t\t * mThumbPosY, (float) (mThumbPosX - mThumbRadius \/ 2 * 1.4),\n\t\t\t * mThumbPosY, mMarkerColorPaint); canvas.restore();\n\t\t\t *\/\n\t\t}\n\n\t\t\/\/ draw the thumb square at the correct rotated position\n\t\tcanvas.save();\n\t\tcanvas.rotate(progressRotation - 90);\n\t\t\/\/ rotate the square by 45 degrees\n\t\t\/*\n\t\t * canvas.rotate(45, mThumbPosX, mThumbPosY); final RectF rect = new\n\t\t * RectF(); rect.left = mThumbPosX - mThumbRadius \/ 3; rect.right =\n\t\t * mThumbPosX + mThumbRadius \/ 3; rect.top = mThumbPosY - mThumbRadius \/\n\t\t * 3; rect.bottom = mThumbPosY + mThumbRadius \/ 3; canvas.drawRect(rect,\n\t\t * mThumbColorPaint);\n\t\t *\/\n\n\t\t\/\/ Correct position\n\t\tcanvas.drawCircle(mThumbPosX, mThumbPosY, mThumbRadius \/ 2,\n\t\t\t\tmThumbColorPaint);\n\t\tcanvas.restore();\n\t}\n\n\t\/*\n\t * (non-Javadoc)\n\t * \n\t * @see android.view.View#onMeasure(int, int)\n\t *\/\n\t@Override\n\tprotected void onMeasure(final int widthMeasureSpec,\n\t\t\tfinal int heightMeasureSpec) {\n\t\tfinal int height = getDefaultSize(getSuggestedMinimumHeight(),\n\t\t\t\theightMeasureSpec);\n\t\tfinal int width = getDefaultSize(getSuggestedMinimumWidth(),\n\t\t\t\twidthMeasureSpec);\n\t\tfinal int min = Math.min(width, height);\n\t\tsetMeasuredDimension(min, height);\n\n\t\tfinal float halfWidth = min * 0.5f;\n\t\tmRadius = halfWidth - mThumbRadius;\n\n\t\tmCircleBounds.set(-mRadius, -mRadius, mRadius, mRadius);\n\n\t\tmThumbPosX = (float) (mRadius * Math.cos(0));\n\t\tmThumbPosY = (float) (mRadius * Math.sin(0));\n\t\tcomputeInsets(width - min, height - min);\n\n\t\tmTranslationOffsetX = halfWidth + mHorizontalInset;\n\t\tmTranslationOffsetY = halfWidth + mVerticalInset;\n\n\t}\n\n\t\/*\n\t * (non-Javadoc)\n\t * \n\t * @see android.view.View#onRestoreInstanceState(android.os.Parcelable)\n\t *\/\n\t@Override\n\tprotected void onRestoreInstanceState(final Parcelable state) {\n\t\tif (state instanceof Bundle) {\n\t\t\tfinal Bundle bundle = (Bundle) state;\n\t\t\tsetProgress(bundle.getFloat(INSTNACE_STATE_PROGRESS));\n\t\t\tsetMarkerProgress(bundle.getFloat(INSTNACE_STATE_MARKER_PROGRESS));\n\t\t\tsuper.onRestoreInstanceState(bundle\n\t\t\t\t\t.getParcelable(INSTNACE_STATE_SAVEDSTATE));\n\t\t\treturn;\n\t\t}\n\n\t\tsuper.onRestoreInstanceState(state);\n\t}\n\n\t\/*\n\t * (non-Javadoc)\n\t * \n\t * @see android.view.View#onSaveInstanceState()\n\t *\/\n\t@Override\n\tprotected Parcelable onSaveInstanceState() {\n\t\tfinal Bundle bundle = new Bundle();\n\t\tbundle.putParcelable(INSTNACE_STATE_SAVEDSTATE,\n\t\t\t\tsuper.onSaveInstanceState());\n\t\tbundle.putFloat(INSTNACE_STATE_PROGRESS, mProgress);\n\t\tbundle.putFloat(INSTNACE_STATE_MARKER_PROGRESS, mMarkerProgress);\n\t\treturn bundle;\n\t}\n\n\t\/**\n\t * Sets the marker enabled.\n\t * \n\t * @param enabled\n\t *            the new marker enabled\n\t *\/\n\tpublic void setMarkerEnabled(final boolean enabled) {\n\t\tmIsMarkerEnabled = enabled;\n\t}\n\n\t\/**\n\t * Sets the marker progress.\n\t * \n\t * @param progress\n\t *            the new marker progress\n\t *\/\n\tpublic void setMarkerProgress(final float progress) {\n\t\tmIsMarkerEnabled = true;\n\t\tmMarkerProgress = progress;\n\t}\n\n\t\/**\n\t * Sets the progress.\n\t * \n\t * @param progress\n\t *            the new progress\n\t *\/\n\tpublic void setProgress(final float progress) {\n\t\tif (progress == mProgress) {\n\t\t\treturn;\n\t\t}\n\n\t\tmProgress = progress % 1.0f;\n\n\t\tif (progress >= 1) {\n\t\t\tmOverrdraw = true;\n\t\t} else {\n\t\t\tmOverrdraw = false;\n\t\t}\n\n\t\tif (!mIsInitializing) {\n\t\t\tinvalidate();\n\t\t}\n\t}\n\n\t\/**\n\t * Sets the progress background color.\n\t * \n\t * @param color\n\t *            the new progress background color\n\t *\/\n\tprivate void setProgressBackgroundColor(final int color) {\n\t\tmProgressBackgroundColor = color;\n\t}\n\n\t\/**\n\t * Sets the progress color.\n\t * \n\t * @param color\n\t *            the new progress color\n\t *\/\n\tprivate void setProgressColor(final int color) {\n\t\tmProgressColor = color;\n\t}\n\n\t\/**\n\t * Sets the wheel size.\n\t * \n\t * @param dimension\n\t *            the new wheel size\n\t *\/\n\tprivate void setWheelSize(final int dimension) {\n\t\tmCircleStrokeWidth = dimension;\n\t}\n\n}"}}
