{"c.functions":{"text":"#include \"radix_tree.h\"\n#include <stdlib.h>\n#include <stdio.h>\n\n#define RT_BRANCH_FACTOR_BIT\t\t(6)\n#define RT_BRANCH_FACTOR\t\t\t(1 << RT_BRANCH_FACTOR_BIT)\n#define RT_BRANCH_FACTOR_MASK\t\t(RT_BRANCH_FACTOR - 1)\n#define RT_MAX_HEIGHT\t\t\t\t(11)\t\/\/  div_round_up (64, 6)\n\nint initialized = 0;\nint max_height;\nstatic unsigned long max_index [RT_MAX_HEIGHT];\n\nstruct radix_node {\n\tunsigned int height;\n\tunsigned int offset;\t\t\t\t\/\/ for shrinking\n\tunsigned int child_count;\n\tunion {\n\t\tstruct radix_node *parent;\n\t\tstruct list_head head;\t\t\t\/\/ for radix tree deletion\n\t};\n\tstruct radix_node *slots [RT_BRANCH_FACTOR];\n};\n\nstatic inline long div_round_up (long n, long d) {\n\tlong tmp = n + d - 1;\n\treturn tmp \/ d;\n}\n\nstatic inline void initialize_max_index (void) {\n\tmax_height = (int) div_round_up (sizeof (unsigned long) << 3, RT_BRANCH_FACTOR_BIT);\n\tint i;\n\tunsigned long last = 1;\n\t\/\/puts (\"max index -----\");\n\tfor (i = 0; i < max_height; ++i) {\n\t\tmax_index[i] = last << RT_BRANCH_FACTOR_BIT;\n\t\tlast = max_index[i];\n\t\t--max_index[i];\n\t\t\/\/printf (\"%lu\\n\", max_index[i]);\n\t}\n}\n\nstatic inline struct radix_data_node * new_radix_data_node (unsigned long key, void *data) {\n\tstruct radix_data_node *retval = (struct radix_data_node*) malloc (sizeof (struct radix_data_node));\n\tif (retval == NULL)\n\t\treturn NULL;\n\n\tretval->key = key;\n\tretval->data = data;\n\tINIT_LIST_HEAD (&retval->iter_head);\n\treturn retval;\n}\n\nstatic inline struct radix_node * new_radix_node (struct radix_node *parent,\n\t\tunsigned int height,\n\t\tunsigned int offset) {\n\tstruct radix_node *retval = (struct radix_node*) malloc (sizeof (struct radix_node));\n\tif (retval == NULL)\n\t\treturn NULL;\n\n\tint i;\n\tstruct radix_node **slots = retval->slots;\n\tfor (i = 0; i < RT_BRANCH_FACTOR; ++i)\n\t\tslots[i] = NULL;\n\n\tretval->height = height;\n\tretval->offset = offset;\n\tretval->child_count = 0;\n\tretval->parent = parent;\n\treturn retval;\n}\n\nstruct radix_tree * new_radix_tree () {\n\tstruct radix_tree *retval = (struct radix_tree*) malloc (sizeof (struct radix_tree));\n\tif (retval == NULL)\n\t\treturn NULL;\n\n\tif (!initialized) {\n\t\tinitialize_max_index ();\n\t\tinitialized = 1;\n\t}\n\n\tretval->size = 0;\n\tretval->root = new_radix_node (NULL, 0, 0);\n\tINIT_LIST_HEAD (&retval->head);\n\tif (retval->root == NULL) {\n\t\tfree (retval);\n\t\tretval = NULL;\n\t}\n\treturn retval;\n}\n\nstatic inline void delete_radix_data_node (struct radix_data_node *data) {\n\tlist_del (&data->iter_head);\n\tfree (data);\n}\n\nstatic inline void delete_radix_node (struct radix_node *node) {\n\tfree (node);\n}\n\n\/\/ BFS delete, no recursion\nvoid delete_radix_tree (struct radix_tree * tree) {\n\tstruct radix_node * node, *slot, **slots;\n\tstruct list_head rhead = LIST_HEAD_INIT (rhead);\n\tint i;\n\n\tnode = tree->root;\n\n\t\/\/ empty tree, don't traverse\n\tif (node == NULL)\n\t\tgoto out_skip_traversal;\n\n\t\/\/ enqueue root node\n\tlist_add_tail (&node->head, &rhead);\n\n\t\/\/ while queue is not empty\n\twhile (rhead.next != &rhead) {\n\t\t\/\/ pop head\n\t\tnode = container_of (rhead.next, struct radix_node, head);\n\t\tlist_del (&node->head);\n\t\tslots = node->slots;\n\t\tif (node->height > 0) {\n\t\t\tfor (i = 0, slot = slots[i];\n\t\t\t\t\ti < RT_BRANCH_FACTOR;\n\t\t\t\t\t++i, slot = slots[i])\n\t\t\t\tif (slot) {\n\t\t\t\t\tlist_add_tail (&slot->head, &rhead);\n\t\t\t\t}\n\t\t} else if (node->height == 0) {\n\t\t\t\/\/ if node->height == 0 -> children are data node, free the struct\n\t\t\tfor (i = 0, slot = slots[i];\n\t\t\t\t\ti < RT_BRANCH_FACTOR;\n\t\t\t\t\t++i, slot = slots[i])\n\t\t\t\tif (slot) {\n\t\t\t\t\tfree (slot);\n\t\t\t\t}\n\t\t} \/\/ else { TODO: dump some shits to debug this damn thing; }\n\t\tfree (node);\n\t}\n\nout_skip_traversal:\n\tfree (tree);\n}\n\nstatic inline struct radix_node * _rt_extend (struct radix_node *root) {\n\tstruct radix_node *retval = new_radix_node (NULL, root->height + 1, 0);\n\tif (retval == NULL)\n\t\treturn NULL;\n\tretval->slots[0] = root;\n\t++retval->child_count;\n\troot->parent = retval;\n\treturn retval;\n}\n\n\/**\n * shrink the tree from the leaf nodes\n *\/\nstatic inline void _rt_shrink_node (struct radix_node *node) {\n\tstruct radix_node *parent;\n\t\/**\n\t * Only shrink radix node without children\n\t *\/\n\twhile (node->child_count == 0) {\n\t\tparent = node->parent;\n\t\tif (parent == NULL)\n\t\t\treturn;\n\t\tparent->slots[node->offset] = NULL;\n\t\t--parent->child_count;\n\t\tdelete_radix_node (node);\n\t\tnode = parent;\n\t}\n}\n\n\/**\n * reduce tree height by shrinking from the root node\n *\/\nstatic inline void _rt_shrink_tree (struct radix_tree *tree) {\n\tstruct radix_node *rnode = tree->root;\n\t\/**\n\t * 1. Only shrink non-leaf root\n\t * 2. Don't shrink branching root\n\t * 3. Only shrink when root acts as zero prefix\n\t *\/\n\twhile (rnode->height > 0 &&\n\t\t\trnode->child_count == 1 &&\n\t\t\trnode->slots[0] != NULL)\n\t{\n\t\ttree->root = rnode->slots[0];\n\t\tdelete_radix_node (rnode);\n\t\trnode = tree->root;\n\t}\n}\n\n\nvoid * radix_tree_insert (struct radix_tree *tree, unsigned long key, void *data) {\n\tvoid * retval = NULL;\n\tstruct radix_data_node *dnode;\n\tstruct radix_node *parent, *slot, **slots;\n\tregister unsigned int height, index, shift;\n\n\tslot = tree->root;\n\twhile (key > max_index[slot->height]) {\n\t\tslot = _rt_extend (slot);\n\t\tif (slot == NULL) {\n\t\t\t\/\/ TODO: Why ??? No memory ???\n\t\t\tputs (\"no memory\");\n\t\t\tgoto out_error_extend;\n\t\t}\n\t\ttree->root = slot;\n\t}\n\n\tparent = tree->root;\n\tslot = NULL;\n\tslots = parent->slots;\n\theight = parent->height;\n\tshift = height * RT_BRANCH_FACTOR_BIT;\n\n\twhile (height > 0) {\n\t\tindex = (key >> shift) & RT_BRANCH_FACTOR_MASK;\n\t\tslot = slots[index];\n\t\tif (slot == NULL) {\n\t\t\t\/\/ grow slot\n\t\t\tslot = new_radix_node (parent, height - 1, index);\n\t\t\tif (slot == NULL) {\n\t\t\t\t\/\/ TODO: Fuck the memory problem\n\t\t\t\tputs (\"no memory\");\n\t\t\t\tgoto out_error;\n\t\t\t} else {\n\t\t\t\tslots[index] = slot;\n\t\t\t\t++parent->child_count;\n\t\t\t}\n\t\t}\n\n\t\t\/\/ move down a level;\n\t\tslots = slot->slots;\n\t\tparent = slot;\n\t\tshift -= RT_BRANCH_FACTOR_BIT;\n\t\t--height;\n\t}\n\n\tindex = key & RT_BRANCH_FACTOR_MASK;\n\tif (slots[index] == NULL) { \/\/ insert if not exist\n\t\tdnode = new_radix_data_node (key, data);\n\t\tif (dnode == NULL) {\n\t\t\t\/\/ TODO: Fuck the memory problem\n\t\t\tputs (\"no memory\");\n\t\t\tgoto out_error;\n\t\t} else {\n\t\t\t++parent->child_count;\n\t\t\t++tree->size;\n\n\t\t\tslots[index] = (struct radix_node*) dnode;\n\t\t\tlist_add_tail (&dnode->iter_head, &tree->head);\n\t\t}\n\t}\n\tretval = slots[index];\n\nout:\n\treturn retval;\n\nout_error:\n\t_rt_shrink_node (parent);\n\nout_error_extend:\n\t_rt_shrink_tree (tree);\n\tretval = NULL;\n\tgoto out;\n}\n\nstatic inline struct radix_node * _rt_find_slot (struct radix_tree *tree, unsigned long key) {\n\tstruct radix_node *retval = NULL;\n\tstruct radix_node *slot, **slots;\n\tregister unsigned int height, index, shift;\n\n\tif (key > max_index[tree->root->height])\n\t\tgoto out;\n\n\tslot = tree->root;\n\tslots = slot->slots;\n\theight = slot->height;\n\tshift = height * RT_BRANCH_FACTOR_BIT;\n\n\twhile (height > 0) {\n\t\tindex = (key >> shift) & RT_BRANCH_FACTOR_MASK;\n\t\tslot = slots[index];\n\t\tif (slot == NULL)\n\t\t\tgoto out;\n\t\tslots = slot->slots;\n\t\tshift -= RT_BRANCH_FACTOR_BIT;\n\t\t--height;\n\t}\n\n\tretval = slot;\n\nout:\n\treturn retval;\n}\n\nstruct radix_data_node * radix_tree_find (struct radix_tree *tree, unsigned long key) {\n\tstruct radix_data_node *retval = NULL;\n\tstruct radix_node *slot;\n\tunsigned int index;\n\n\tslot = _rt_find_slot (tree, key);\n\tif (slot == NULL)\n\t\tgoto out;\n\n\tindex = key & RT_BRANCH_FACTOR_MASK;\n\tretval = (struct radix_data_node *) slot->slots[index];\n\nout:\n\treturn retval;\n}\n\/\/ return the data associated with the key\nvoid * radix_tree_delete (struct radix_tree *tree, unsigned long key) {\n\tvoid * retval = NULL;\n\tunsigned int index;\n\tstruct radix_data_node *dnode;\n\tstruct radix_node *slot = _rt_find_slot (tree, key);\n\tif (slot == NULL)\n\t\tgoto out;\n\n\tindex = key & RT_BRANCH_FACTOR_MASK;\n\tdnode = (struct radix_data_node *) slot->slots[index];\n\tif (dnode == NULL)\n\t\tgoto out;\n\n\tretval = dnode->data;\n\tdelete_radix_data_node (dnode);\n\tslot->slots[index] = NULL;\n\t--slot->child_count;\n\t_rt_shrink_node (slot);\n\t_rt_shrink_tree (tree);\n\nout:\n\treturn retval;\n}\n\n\/\/ DFS radix tree dump\nvoid radix_tree_dfs_dump (struct radix_node *node, unsigned long prefix) {\n\tstruct radix_node **slots = node->slots, *slot;\n\tunsigned int height = node->height;\n\tint i, j, k;\n\n\tfor (i = 0; i < RT_BRANCH_FACTOR; ++i) {\n\t\tslot = slots[i];\n\t\tif (slot) {\n\t\t\tif (height > 0) { \/\/ internal nodes\n\t\t\t\tradix_tree_dfs_dump (slot, prefix | (i << (RT_BRANCH_FACTOR_BIT * height)));\n\t\t\t} else { \/\/ leaf node, data node\n\t\t\t\tstruct radix_data_node * dnode = (struct radix_data_node *) slot;\n\t\t\t\tprefix |= i;\n\t\t\t\tprintf (\"0x%lx->(0x%lx, %p)\\n\", prefix, dnode->key, dnode->data);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid radix_tree_dump (struct radix_tree *tree) {\n\tstruct radix_node * node, *slot, **slots;\n\tstruct list_head rhead = LIST_HEAD_INIT (rhead);\n\tint i, empty;\n\n\tnode = tree->root;\n\tradix_tree_dfs_dump (node, 0);\n}\n","pos":1,"subs":[{"c.function":{"text":"\n\nstatic inline long div_round_up (long n, long d) {","pos":605,"subs":[{"c.static":{"text":"static","pos":607}},{"c.inline":{"text":"inline","pos":614}},{"c.return_type":{"text":"long ","pos":621}},{"c.function_name":{"text":"div_round_up ","pos":626}},{"c.parameters":{"text":"(long n, long d) ","pos":639,"subs":[{"c.single_param":{"text":"long n","pos":640}},{"c.single_param":{"text":" long d","pos":647}}]}}]}},{"c.function":{"text":"\n\nstatic inline void initialize_max_index (void) {","pos":699,"subs":[{"c.static":{"text":"static","pos":701}},{"c.inline":{"text":"inline","pos":708}},{"c.return_type":{"text":"void ","pos":715}},{"c.function_name":{"text":"initialize_max_index ","pos":720}},{"c.parameters":{"text":"(void) ","pos":741,"subs":[{"c.single_param":{"text":"void","pos":742}}]}}]}},{"c.function":{"text":"\n\nstatic inline struct radix_data_node * new_radix_data_node (unsigned long key, void *data) {","pos":1062,"subs":[{"c.static":{"text":"static","pos":1064}},{"c.inline":{"text":"inline","pos":1071}},{"c.return_type":{"text":"struct radix_data_node *","pos":1078}},{"c.function_name":{"text":"new_radix_data_node ","pos":1103}},{"c.parameters":{"text":"(unsigned long key, void *data) ","pos":1123,"subs":[{"c.single_param":{"text":"unsigned long key","pos":1124}},{"c.single_param":{"text":" void *data","pos":1142}}]}}]}},{"c.function":{"text":"\n\nstatic inline struct radix_node * new_radix_node (struct radix_node *parent,\n\t\tunsigned int height,\n\t\tunsigned int offset) {","pos":1393,"subs":[{"c.static":{"text":"static","pos":1395}},{"c.inline":{"text":"inline","pos":1402}},{"c.return_type":{"text":"struct radix_node *","pos":1409}},{"c.function_name":{"text":"new_radix_node ","pos":1429}},{"c.parameters":{"text":"(struct radix_node *parent,\n\t\tunsigned int height,\n\t\tunsigned int offset) ","pos":1444,"subs":[{"c.single_param":{"text":"struct radix_node *parent","pos":1445}},{"c.single_param":{"text":"\n\t\tunsigned int height","pos":1471}},{"c.single_param":{"text":"\n\t\tunsigned int offset","pos":1494}}]}}]}},{"c.function":{"text":"\n\nstruct radix_tree * new_radix_tree () {","pos":1877,"subs":[{"c.return_type":{"text":"struct radix_tree *","pos":1879}},{"c.function_name":{"text":"new_radix_tree ","pos":1899}},{"c.parameters":{"text":"() ","pos":1914,"subs":[{"c.single_param":{"text":"","pos":1915}}]}}]}},{"c.function":{"text":"\n\nstatic inline void delete_radix_data_node (struct radix_data_node *data) {","pos":2294,"subs":[{"c.static":{"text":"static","pos":2296}},{"c.inline":{"text":"inline","pos":2303}},{"c.return_type":{"text":"void ","pos":2310}},{"c.function_name":{"text":"delete_radix_data_node ","pos":2315}},{"c.parameters":{"text":"(struct radix_data_node *data) ","pos":2338,"subs":[{"c.single_param":{"text":"struct radix_data_node *data","pos":2339}}]}}]}},{"c.function":{"text":"\n\nstatic inline void delete_radix_node (struct radix_node *node) {","pos":2416,"subs":[{"c.static":{"text":"static","pos":2418}},{"c.inline":{"text":"inline","pos":2425}},{"c.return_type":{"text":"void ","pos":2432}},{"c.function_name":{"text":"delete_radix_node ","pos":2437}},{"c.parameters":{"text":"(struct radix_node *node) ","pos":2455,"subs":[{"c.single_param":{"text":"struct radix_node *node","pos":2456}}]}}]}},{"c.function":{"text":" recursion\nvoid delete_radix_tree (struct radix_tree * tree) {","pos":2517,"subs":[{"c.return_type":{"text":"recursion\n","pos":2518}},{"c.function_name":{"text":"void delete_radix_tree ","pos":2528}},{"c.parameters":{"text":"(struct radix_tree * tree) ","pos":2551,"subs":[{"c.single_param":{"text":"struct radix_tree * tree","pos":2552}}]}}]}},{"c.function":{"text":"\n\nstatic inline struct radix_node * _rt_extend (struct radix_node *root) {","pos":3551,"subs":[{"c.static":{"text":"static","pos":3553}},{"c.inline":{"text":"inline","pos":3560}},{"c.return_type":{"text":"struct radix_node *","pos":3567}},{"c.function_name":{"text":"_rt_extend ","pos":3587}},{"c.parameters":{"text":"(struct radix_node *root) ","pos":3598,"subs":[{"c.single_param":{"text":"struct radix_node *root","pos":3599}}]}}]}},{"c.function":{"text":"\nstatic inline void _rt_shrink_node (struct radix_node *node) {","pos":3874,"subs":[{"c.static":{"text":"static","pos":3875}},{"c.inline":{"text":"inline","pos":3882}},{"c.return_type":{"text":"void ","pos":3889}},{"c.function_name":{"text":"_rt_shrink_node ","pos":3894}},{"c.parameters":{"text":"(struct radix_node *node) ","pos":3910,"subs":[{"c.single_param":{"text":"struct radix_node *node","pos":3911}}]}}]}},{"c.function":{"text":"\nstatic inline void _rt_shrink_tree (struct radix_tree *tree) {","pos":4287,"subs":[{"c.static":{"text":"static","pos":4288}},{"c.inline":{"text":"inline","pos":4295}},{"c.return_type":{"text":"void ","pos":4302}},{"c.function_name":{"text":"_rt_shrink_tree ","pos":4307}},{"c.parameters":{"text":"(struct radix_tree *tree) ","pos":4323,"subs":[{"c.single_param":{"text":"struct radix_tree *tree","pos":4324}}]}}]}},{"c.function":{"text":"\n\n\nvoid * radix_tree_insert (struct radix_tree *tree, unsigned long key, void *data) {","pos":4695,"subs":[{"c.return_type":{"text":"void *","pos":4698}},{"c.function_name":{"text":"radix_tree_insert ","pos":4705}},{"c.parameters":{"text":"(struct radix_tree *tree, unsigned long key, void *data) ","pos":4723,"subs":[{"c.single_param":{"text":"struct radix_tree *tree","pos":4724}},{"c.single_param":{"text":" unsigned long key","pos":4748}},{"c.single_param":{"text":" void *data","pos":4767}}]}}]}},{"c.function":{"text":"\n\nstatic inline struct radix_node * _rt_find_slot (struct radix_tree *tree, unsigned long key) {","pos":6305,"subs":[{"c.static":{"text":"static","pos":6307}},{"c.inline":{"text":"inline","pos":6314}},{"c.return_type":{"text":"struct radix_node *","pos":6321}},{"c.function_name":{"text":"_rt_find_slot ","pos":6341}},{"c.parameters":{"text":"(struct radix_tree *tree, unsigned long key) ","pos":6355,"subs":[{"c.single_param":{"text":"struct radix_tree *tree","pos":6356}},{"c.single_param":{"text":" unsigned long key","pos":6380}}]}}]}},{"c.function":{"text":"\n\nstruct radix_data_node * radix_tree_find (struct radix_tree *tree, unsigned long key) {","pos":6919,"subs":[{"c.return_type":{"text":"struct radix_data_node *","pos":6921}},{"c.function_name":{"text":"radix_tree_find ","pos":6946}},{"c.parameters":{"text":"(struct radix_tree *tree, unsigned long key) ","pos":6962,"subs":[{"c.single_param":{"text":"struct radix_tree *tree","pos":6963}},{"c.single_param":{"text":" unsigned long key","pos":6987}}]}}]}},{"c.function":{"text":" key\nvoid * radix_tree_delete (struct radix_tree *tree, unsigned long key) {","pos":7321,"subs":[{"c.return_type":{"text":"key\n","pos":7322}},{"c.function_name":{"text":"void * radix_tree_delete ","pos":7326}},{"c.parameters":{"text":"(struct radix_tree *tree, unsigned long key) ","pos":7351,"subs":[{"c.single_param":{"text":"struct radix_tree *tree","pos":7352}},{"c.single_param":{"text":" unsigned long key","pos":7376}}]}}]}},{"c.function":{"text":" dump\nvoid radix_tree_dfs_dump (struct radix_node *node, unsigned long prefix) {","pos":7885,"subs":[{"c.return_type":{"text":"dump\n","pos":7886}},{"c.function_name":{"text":"void radix_tree_dfs_dump ","pos":7891}},{"c.parameters":{"text":"(struct radix_node *node, unsigned long prefix) ","pos":7916,"subs":[{"c.single_param":{"text":"struct radix_node *node","pos":7917}},{"c.single_param":{"text":" unsigned long prefix","pos":7941}}]}}]}},{"c.function":{"text":"\n\nvoid radix_tree_dump (struct radix_tree *tree) {","pos":8468,"subs":[{"c.return_type":{"text":"void ","pos":8470}},{"c.function_name":{"text":"radix_tree_dump ","pos":8475}},{"c.parameters":{"text":"(struct radix_tree *tree) ","pos":8491,"subs":[{"c.single_param":{"text":"struct radix_tree *tree","pos":8492}}]}}]}}]}}
