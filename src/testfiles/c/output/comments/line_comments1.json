{"c.line_comments":{"pos":1,"subs":[{"c.line_comment":{"pos":208,"subs":[{"c.line_comment_context":{"pos":208,"text":"#define RT_MAX_HEIGHT\t\t\t\t(11)\t"}},{"c.line_comment_body":{"pos":238,"subs":[{"c.line_comment_text":{"pos":240,"text":"  div_round_up (64, 6)"}}],"text":"\/\/  div_round_up (64, 6)"}}],"text":"#define RT_MAX_HEIGHT\t\t\t\t(11)\t\/\/  div_round_up (64, 6)"}},{"c.line_comment":{"pos":392,"subs":[{"c.line_comment_context":{"pos":392,"text":"\tunsigned int offset;\t\t\t\t"}},{"c.line_comment_body":{"pos":417,"subs":[{"c.line_comment_text":{"pos":419,"text":" for shrinking"}}],"text":"\/\/ for shrinking"}}],"text":"\tunsigned int offset;\t\t\t\t\/\/ for shrinking"}},{"c.line_comment":{"pos":499,"subs":[{"c.line_comment_context":{"pos":499,"text":"\t\tstruct list_head head;\t\t\t"}},{"c.line_comment_body":{"pos":526,"subs":[{"c.line_comment_text":{"pos":528,"text":" for radix tree deletion"}}],"text":"\/\/ for radix tree deletion"}}],"text":"\t\tstruct list_head head;\t\t\t\/\/ for radix tree deletion"}},{"c.line_comment":{"pos":869,"subs":[{"c.line_comment_context":{"pos":869,"text":"\t"}},{"c.line_comment_body":{"pos":870,"subs":[{"c.line_comment_text":{"pos":872,"text":"puts (\"max index -----\");"}}],"text":"\/\/puts (\"max index -----\");"}}],"text":"\t\/\/puts (\"max index -----\");"}},{"c.line_comment":{"pos":1022,"subs":[{"c.line_comment_context":{"pos":1022,"text":"\t\t"}},{"c.line_comment_body":{"pos":1024,"subs":[{"c.line_comment_text":{"pos":1026,"text":"printf (\"%lu\\n\", max_index[i]);"}}],"text":"\/\/printf (\"%lu\\n\", max_index[i]);"}}],"text":"\t\t\/\/printf (\"%lu\\n\", max_index[i]);"}},{"c.line_comment":{"pos":2500,"subs":[{"c.line_comment_context":{"pos":2500,"text":""}},{"c.line_comment_body":{"pos":2500,"subs":[{"c.line_comment_text":{"pos":2502,"text":" BFS delete, no recursion"}}],"text":"\/\/ BFS delete, no recursion"}}],"text":"\/\/ BFS delete, no recursion"}},{"c.line_comment":{"pos":2703,"subs":[{"c.line_comment_context":{"pos":2703,"text":"\t"}},{"c.line_comment_body":{"pos":2704,"subs":[{"c.line_comment_text":{"pos":2706,"text":" empty tree, don't traverse"}}],"text":"\/\/ empty tree, don't traverse"}}],"text":"\t\/\/ empty tree, don't traverse"}},{"c.line_comment":{"pos":2781,"subs":[{"c.line_comment_context":{"pos":2781,"text":"\t"}},{"c.line_comment_body":{"pos":2782,"subs":[{"c.line_comment_text":{"pos":2784,"text":" enqueue root node"}}],"text":"\/\/ enqueue root node"}}],"text":"\t\/\/ enqueue root node"}},{"c.line_comment":{"pos":2842,"subs":[{"c.line_comment_context":{"pos":2842,"text":"\t"}},{"c.line_comment_body":{"pos":2843,"subs":[{"c.line_comment_text":{"pos":2845,"text":" while queue is not empty"}}],"text":"\/\/ while queue is not empty"}}],"text":"\t\/\/ while queue is not empty"}},{"c.line_comment":{"pos":2903,"subs":[{"c.line_comment_context":{"pos":2903,"text":"\t\t"}},{"c.line_comment_body":{"pos":2905,"subs":[{"c.line_comment_text":{"pos":2907,"text":" pop head"}}],"text":"\/\/ pop head"}}],"text":"\t\t\/\/ pop head"}},{"c.line_comment":{"pos":3237,"subs":[{"c.line_comment_context":{"pos":3237,"text":"\t\t\t"}},{"c.line_comment_body":{"pos":3240,"subs":[{"c.line_comment_text":{"pos":3242,"text":" if node->height == 0 -> children are data node, free the struct"}}],"text":"\/\/ if node->height == 0 -> children are data node, free the struct"}}],"text":"\t\t\t\/\/ if node->height == 0 -> children are data node, free the struct"}},{"c.line_comment":{"pos":3433,"subs":[{"c.line_comment_context":{"pos":3433,"text":"\t\t} "}},{"c.line_comment_body":{"pos":3437,"subs":[{"c.line_comment_text":{"pos":3439,"text":" else { TODO: dump some shits to debug this damn thing; }"}}],"text":"\/\/ else { TODO: dump some shits to debug this damn thing; }"}}],"text":"\t\t} \/\/ else { TODO: dump some shits to debug this damn thing; }"}},{"c.line_comment":{"pos":5038,"subs":[{"c.line_comment_context":{"pos":5038,"text":"\t\t\t"}},{"c.line_comment_body":{"pos":5041,"subs":[{"c.line_comment_text":{"pos":5043,"text":" TODO: Why ??? No memory ???"}}],"text":"\/\/ TODO: Why ??? No memory ???"}}],"text":"\t\t\t\/\/ TODO: Why ??? No memory ???"}},{"c.line_comment":{"pos":5394,"subs":[{"c.line_comment_context":{"pos":5394,"text":"\t\t\t"}},{"c.line_comment_body":{"pos":5397,"subs":[{"c.line_comment_text":{"pos":5399,"text":" grow slot"}}],"text":"\/\/ grow slot"}}],"text":"\t\t\t\/\/ grow slot"}},{"c.line_comment":{"pos":5487,"subs":[{"c.line_comment_context":{"pos":5487,"text":"\t\t\t\t"}},{"c.line_comment_body":{"pos":5491,"subs":[{"c.line_comment_text":{"pos":5493,"text":" TODO: Fuck the memory problem"}}],"text":"\/\/ TODO: Fuck the memory problem"}}],"text":"\t\t\t\t\/\/ TODO: Fuck the memory problem"}},{"c.line_comment":{"pos":5642,"subs":[{"c.line_comment_context":{"pos":5642,"text":"\t\t"}},{"c.line_comment_body":{"pos":5644,"subs":[{"c.line_comment_text":{"pos":5646,"text":" move down a level;"}}],"text":"\/\/ move down a level;"}}],"text":"\t\t\/\/ move down a level;"}},{"c.line_comment":{"pos":5793,"subs":[{"c.line_comment_context":{"pos":5793,"text":"\tif (slots[index] == NULL) { "}},{"c.line_comment_body":{"pos":5822,"subs":[{"c.line_comment_text":{"pos":5824,"text":" insert if not exist"}}],"text":"\/\/ insert if not exist"}}],"text":"\tif (slots[index] == NULL) { \/\/ insert if not exist"}},{"c.line_comment":{"pos":5911,"subs":[{"c.line_comment_context":{"pos":5911,"text":"\t\t\t"}},{"c.line_comment_body":{"pos":5914,"subs":[{"c.line_comment_text":{"pos":5916,"text":" TODO: Fuck the memory problem"}}],"text":"\/\/ TODO: Fuck the memory problem"}}],"text":"\t\t\t\/\/ TODO: Fuck the memory problem"}},{"c.line_comment":{"pos":7283,"subs":[{"c.line_comment_context":{"pos":7283,"text":""}},{"c.line_comment_body":{"pos":7283,"subs":[{"c.line_comment_text":{"pos":7285,"text":" return the data associated with the key"}}],"text":"\/\/ return the data associated with the key"}}],"text":"\/\/ return the data associated with the key"}},{"c.line_comment":{"pos":7868,"subs":[{"c.line_comment_context":{"pos":7868,"text":""}},{"c.line_comment_body":{"pos":7868,"subs":[{"c.line_comment_text":{"pos":7870,"text":" DFS radix tree dump"}}],"text":"\/\/ DFS radix tree dump"}}],"text":"\/\/ DFS radix tree dump"}},{"c.line_comment":{"pos":8142,"subs":[{"c.line_comment_context":{"pos":8142,"text":"\t\t\tif (height > 0) { "}},{"c.line_comment_body":{"pos":8163,"subs":[{"c.line_comment_text":{"pos":8165,"text":" internal nodes"}}],"text":"\/\/ internal nodes"}}],"text":"\t\t\tif (height > 0) { \/\/ internal nodes"}},{"c.line_comment":{"pos":8262,"subs":[{"c.line_comment_context":{"pos":8262,"text":"\t\t\t} else { "}},{"c.line_comment_body":{"pos":8274,"subs":[{"c.line_comment_text":{"pos":8276,"text":" leaf node, data node"}}],"text":"\/\/ leaf node, data node"}}],"text":"\t\t\t} else { \/\/ leaf node, data node"}}],"text":"#include \"radix_tree.h\"\n#include <stdlib.h>\n#include <stdio.h>\n\n#define RT_BRANCH_FACTOR_BIT\t\t(6)\n#define RT_BRANCH_FACTOR\t\t\t(1 << RT_BRANCH_FACTOR_BIT)\n#define RT_BRANCH_FACTOR_MASK\t\t(RT_BRANCH_FACTOR - 1)\n#define RT_MAX_HEIGHT\t\t\t\t(11)\t\/\/  div_round_up (64, 6)\n\nint initialized = 0;\nint max_height;\nstatic unsigned long max_index [RT_MAX_HEIGHT];\n\nstruct radix_node {\n\tunsigned int height;\n\tunsigned int offset;\t\t\t\t\/\/ for shrinking\n\tunsigned int child_count;\n\tunion {\n\t\tstruct radix_node *parent;\n\t\tstruct list_head head;\t\t\t\/\/ for radix tree deletion\n\t};\n\tstruct radix_node *slots [RT_BRANCH_FACTOR];\n};\n\nstatic inline long div_round_up (long n, long d) {\n\tlong tmp = n + d - 1;\n\treturn tmp \/ d;\n}\n\nstatic inline void initialize_max_index (void) {\n\tmax_height = (int) div_round_up (sizeof (unsigned long) << 3, RT_BRANCH_FACTOR_BIT);\n\tint i;\n\tunsigned long last = 1;\n\t\/\/puts (\"max index -----\");\n\tfor (i = 0; i < max_height; ++i) {\n\t\tmax_index[i] = last << RT_BRANCH_FACTOR_BIT;\n\t\tlast = max_index[i];\n\t\t--max_index[i];\n\t\t\/\/printf (\"%lu\\n\", max_index[i]);\n\t}\n}\n\nstatic inline struct radix_data_node * new_radix_data_node (unsigned long key, void *data) {\n\tstruct radix_data_node *retval = (struct radix_data_node*) malloc (sizeof (struct radix_data_node));\n\tif (retval == NULL)\n\t\treturn NULL;\n\n\tretval->key = key;\n\tretval->data = data;\n\tINIT_LIST_HEAD (&retval->iter_head);\n\treturn retval;\n}\n\nstatic inline struct radix_node * new_radix_node (struct radix_node *parent,\n\t\tunsigned int height,\n\t\tunsigned int offset) {\n\tstruct radix_node *retval = (struct radix_node*) malloc (sizeof (struct radix_node));\n\tif (retval == NULL)\n\t\treturn NULL;\n\n\tint i;\n\tstruct radix_node **slots = retval->slots;\n\tfor (i = 0; i < RT_BRANCH_FACTOR; ++i)\n\t\tslots[i] = NULL;\n\n\tretval->height = height;\n\tretval->offset = offset;\n\tretval->child_count = 0;\n\tretval->parent = parent;\n\treturn retval;\n}\n\nstruct radix_tree * new_radix_tree () {\n\tstruct radix_tree *retval = (struct radix_tree*) malloc (sizeof (struct radix_tree));\n\tif (retval == NULL)\n\t\treturn NULL;\n\n\tif (!initialized) {\n\t\tinitialize_max_index ();\n\t\tinitialized = 1;\n\t}\n\n\tretval->size = 0;\n\tretval->root = new_radix_node (NULL, 0, 0);\n\tINIT_LIST_HEAD (&retval->head);\n\tif (retval->root == NULL) {\n\t\tfree (retval);\n\t\tretval = NULL;\n\t}\n\treturn retval;\n}\n\nstatic inline void delete_radix_data_node (struct radix_data_node *data) {\n\tlist_del (&data->iter_head);\n\tfree (data);\n}\n\nstatic inline void delete_radix_node (struct radix_node *node) {\n\tfree (node);\n}\n\n\/\/ BFS delete, no recursion\nvoid delete_radix_tree (struct radix_tree * tree) {\n\tstruct radix_node * node, *slot, **slots;\n\tstruct list_head rhead = LIST_HEAD_INIT (rhead);\n\tint i;\n\n\tnode = tree->root;\n\n\t\/\/ empty tree, don't traverse\n\tif (node == NULL)\n\t\tgoto out_skip_traversal;\n\n\t\/\/ enqueue root node\n\tlist_add_tail (&node->head, &rhead);\n\n\t\/\/ while queue is not empty\n\twhile (rhead.next != &rhead) {\n\t\t\/\/ pop head\n\t\tnode = container_of (rhead.next, struct radix_node, head);\n\t\tlist_del (&node->head);\n\t\tslots = node->slots;\n\t\tif (node->height > 0) {\n\t\t\tfor (i = 0, slot = slots[i];\n\t\t\t\t\ti < RT_BRANCH_FACTOR;\n\t\t\t\t\t++i, slot = slots[i])\n\t\t\t\tif (slot) {\n\t\t\t\t\tlist_add_tail (&slot->head, &rhead);\n\t\t\t\t}\n\t\t} else if (node->height == 0) {\n\t\t\t\/\/ if node->height == 0 -> children are data node, free the struct\n\t\t\tfor (i = 0, slot = slots[i];\n\t\t\t\t\ti < RT_BRANCH_FACTOR;\n\t\t\t\t\t++i, slot = slots[i])\n\t\t\t\tif (slot) {\n\t\t\t\t\tfree (slot);\n\t\t\t\t}\n\t\t} \/\/ else { TODO: dump some shits to debug this damn thing; }\n\t\tfree (node);\n\t}\n\nout_skip_traversal:\n\tfree (tree);\n}\n\nstatic inline struct radix_node * _rt_extend (struct radix_node *root) {\n\tstruct radix_node *retval = new_radix_node (NULL, root->height + 1, 0);\n\tif (retval == NULL)\n\t\treturn NULL;\n\tretval->slots[0] = root;\n\t++retval->child_count;\n\troot->parent = retval;\n\treturn retval;\n}\n\n\/**\n * shrink the tree from the leaf nodes\n *\/\nstatic inline void _rt_shrink_node (struct radix_node *node) {\n\tstruct radix_node *parent;\n\t\/**\n\t * Only shrink radix node without children\n\t *\/\n\twhile (node->child_count == 0) {\n\t\tparent = node->parent;\n\t\tif (parent == NULL)\n\t\t\treturn;\n\t\tparent->slots[node->offset] = NULL;\n\t\t--parent->child_count;\n\t\tdelete_radix_node (node);\n\t\tnode = parent;\n\t}\n}\n\n\/**\n * reduce tree height by shrinking from the root node\n *\/\nstatic inline void _rt_shrink_tree (struct radix_tree *tree) {\n\tstruct radix_node *rnode = tree->root;\n\t\/**\n\t * 1. Only shrink non-leaf root\n\t * 2. Don't shrink branching root\n\t * 3. Only shrink when root acts as zero prefix\n\t *\/\n\twhile (rnode->height > 0 &&\n\t\t\trnode->child_count == 1 &&\n\t\t\trnode->slots[0] != NULL)\n\t{\n\t\ttree->root = rnode->slots[0];\n\t\tdelete_radix_node (rnode);\n\t\trnode = tree->root;\n\t}\n}\n\n\nvoid * radix_tree_insert (struct radix_tree *tree, unsigned long key, void *data) {\n\tvoid * retval = NULL;\n\tstruct radix_data_node *dnode;\n\tstruct radix_node *parent, *slot, **slots;\n\tregister unsigned int height, index, shift;\n\n\tslot = tree->root;\n\twhile (key > max_index[slot->height]) {\n\t\tslot = _rt_extend (slot);\n\t\tif (slot == NULL) {\n\t\t\t\/\/ TODO: Why ??? No memory ???\n\t\t\tputs (\"no memory\");\n\t\t\tgoto out_error_extend;\n\t\t}\n\t\ttree->root = slot;\n\t}\n\n\tparent = tree->root;\n\tslot = NULL;\n\tslots = parent->slots;\n\theight = parent->height;\n\tshift = height * RT_BRANCH_FACTOR_BIT;\n\n\twhile (height > 0) {\n\t\tindex = (key >> shift) & RT_BRANCH_FACTOR_MASK;\n\t\tslot = slots[index];\n\t\tif (slot == NULL) {\n\t\t\t\/\/ grow slot\n\t\t\tslot = new_radix_node (parent, height - 1, index);\n\t\t\tif (slot == NULL) {\n\t\t\t\t\/\/ TODO: Fuck the memory problem\n\t\t\t\tputs (\"no memory\");\n\t\t\t\tgoto out_error;\n\t\t\t} else {\n\t\t\t\tslots[index] = slot;\n\t\t\t\t++parent->child_count;\n\t\t\t}\n\t\t}\n\n\t\t\/\/ move down a level;\n\t\tslots = slot->slots;\n\t\tparent = slot;\n\t\tshift -= RT_BRANCH_FACTOR_BIT;\n\t\t--height;\n\t}\n\n\tindex = key & RT_BRANCH_FACTOR_MASK;\n\tif (slots[index] == NULL) { \/\/ insert if not exist\n\t\tdnode = new_radix_data_node (key, data);\n\t\tif (dnode == NULL) {\n\t\t\t\/\/ TODO: Fuck the memory problem\n\t\t\tputs (\"no memory\");\n\t\t\tgoto out_error;\n\t\t} else {\n\t\t\t++parent->child_count;\n\t\t\t++tree->size;\n\n\t\t\tslots[index] = (struct radix_node*) dnode;\n\t\t\tlist_add_tail (&dnode->iter_head, &tree->head);\n\t\t}\n\t}\n\tretval = slots[index];\n\nout:\n\treturn retval;\n\nout_error:\n\t_rt_shrink_node (parent);\n\nout_error_extend:\n\t_rt_shrink_tree (tree);\n\tretval = NULL;\n\tgoto out;\n}\n\nstatic inline struct radix_node * _rt_find_slot (struct radix_tree *tree, unsigned long key) {\n\tstruct radix_node *retval = NULL;\n\tstruct radix_node *slot, **slots;\n\tregister unsigned int height, index, shift;\n\n\tif (key > max_index[tree->root->height])\n\t\tgoto out;\n\n\tslot = tree->root;\n\tslots = slot->slots;\n\theight = slot->height;\n\tshift = height * RT_BRANCH_FACTOR_BIT;\n\n\twhile (height > 0) {\n\t\tindex = (key >> shift) & RT_BRANCH_FACTOR_MASK;\n\t\tslot = slots[index];\n\t\tif (slot == NULL)\n\t\t\tgoto out;\n\t\tslots = slot->slots;\n\t\tshift -= RT_BRANCH_FACTOR_BIT;\n\t\t--height;\n\t}\n\n\tretval = slot;\n\nout:\n\treturn retval;\n}\n\nstruct radix_data_node * radix_tree_find (struct radix_tree *tree, unsigned long key) {\n\tstruct radix_data_node *retval = NULL;\n\tstruct radix_node *slot;\n\tunsigned int index;\n\n\tslot = _rt_find_slot (tree, key);\n\tif (slot == NULL)\n\t\tgoto out;\n\n\tindex = key & RT_BRANCH_FACTOR_MASK;\n\tretval = (struct radix_data_node *) slot->slots[index];\n\nout:\n\treturn retval;\n}\n\/\/ return the data associated with the key\nvoid * radix_tree_delete (struct radix_tree *tree, unsigned long key) {\n\tvoid * retval = NULL;\n\tunsigned int index;\n\tstruct radix_data_node *dnode;\n\tstruct radix_node *slot = _rt_find_slot (tree, key);\n\tif (slot == NULL)\n\t\tgoto out;\n\n\tindex = key & RT_BRANCH_FACTOR_MASK;\n\tdnode = (struct radix_data_node *) slot->slots[index];\n\tif (dnode == NULL)\n\t\tgoto out;\n\n\tretval = dnode->data;\n\tdelete_radix_data_node (dnode);\n\tslot->slots[index] = NULL;\n\t--slot->child_count;\n\t_rt_shrink_node (slot);\n\t_rt_shrink_tree (tree);\n\nout:\n\treturn retval;\n}\n\n\/\/ DFS radix tree dump\nvoid radix_tree_dfs_dump (struct radix_node *node, unsigned long prefix) {\n\tstruct radix_node **slots = node->slots, *slot;\n\tunsigned int height = node->height;\n\tint i, j, k;\n\n\tfor (i = 0; i < RT_BRANCH_FACTOR; ++i) {\n\t\tslot = slots[i];\n\t\tif (slot) {\n\t\t\tif (height > 0) { \/\/ internal nodes\n\t\t\t\tradix_tree_dfs_dump (slot, prefix | (i << (RT_BRANCH_FACTOR_BIT * height)));\n\t\t\t} else { \/\/ leaf node, data node\n\t\t\t\tstruct radix_data_node * dnode = (struct radix_data_node *) slot;\n\t\t\t\tprefix |= i;\n\t\t\t\tprintf (\"0x%lx->(0x%lx, %p)\\n\", prefix, dnode->key, dnode->data);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid radix_tree_dump (struct radix_tree *tree) {\n\tstruct radix_node * node, *slot, **slots;\n\tstruct list_head rhead = LIST_HEAD_INIT (rhead);\n\tint i, empty;\n\n\tnode = tree->root;\n\tradix_tree_dfs_dump (node, 0);\n}\n"}}
