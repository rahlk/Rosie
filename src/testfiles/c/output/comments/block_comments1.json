{"c.block_comments":{"text":"#include \"radix_tree.h\"\n#include <stdlib.h>\n#include <stdio.h>\n\n#define RT_BRANCH_FACTOR_BIT\t\t(6)\n#define RT_BRANCH_FACTOR\t\t\t(1 << RT_BRANCH_FACTOR_BIT)\n#define RT_BRANCH_FACTOR_MASK\t\t(RT_BRANCH_FACTOR - 1)\n#define RT_MAX_HEIGHT\t\t\t\t(11)\t\/\/  div_round_up (64, 6)\n\nint initialized = 0;\nint max_height;\nstatic unsigned long max_index [RT_MAX_HEIGHT];\n\nstruct radix_node {\n\tunsigned int height;\n\tunsigned int offset;\t\t\t\t\/\/ for shrinking\n\tunsigned int child_count;\n\tunion {\n\t\tstruct radix_node *parent;\n\t\tstruct list_head head;\t\t\t\/\/ for radix tree deletion\n\t};\n\tstruct radix_node *slots [RT_BRANCH_FACTOR];\n};\n\nstatic inline long div_round_up (long n, long d) {\n\tlong tmp = n + d - 1;\n\treturn tmp \/ d;\n}\n\nstatic inline void initialize_max_index (void) {\n\tmax_height = (int) div_round_up (sizeof (unsigned long) << 3, RT_BRANCH_FACTOR_BIT);\n\tint i;\n\tunsigned long last = 1;\n\t\/\/puts (\"max index -----\");\n\tfor (i = 0; i < max_height; ++i) {\n\t\tmax_index[i] = last << RT_BRANCH_FACTOR_BIT;\n\t\tlast = max_index[i];\n\t\t--max_index[i];\n\t\t\/\/printf (\"%lu\\n\", max_index[i]);\n\t}\n}\n\nstatic inline struct radix_data_node * new_radix_data_node (unsigned long key, void *data) {\n\tstruct radix_data_node *retval = (struct radix_data_node*) malloc (sizeof (struct radix_data_node));\n\tif (retval == NULL)\n\t\treturn NULL;\n\n\tretval->key = key;\n\tretval->data = data;\n\tINIT_LIST_HEAD (&retval->iter_head);\n\treturn retval;\n}\n\nstatic inline struct radix_node * new_radix_node (struct radix_node *parent,\n\t\tunsigned int height,\n\t\tunsigned int offset) {\n\tstruct radix_node *retval = (struct radix_node*) malloc (sizeof (struct radix_node));\n\tif (retval == NULL)\n\t\treturn NULL;\n\n\tint i;\n\tstruct radix_node **slots = retval->slots;\n\tfor (i = 0; i < RT_BRANCH_FACTOR; ++i)\n\t\tslots[i] = NULL;\n\n\tretval->height = height;\n\tretval->offset = offset;\n\tretval->child_count = 0;\n\tretval->parent = parent;\n\treturn retval;\n}\n\nstruct radix_tree * new_radix_tree () {\n\tstruct radix_tree *retval = (struct radix_tree*) malloc (sizeof (struct radix_tree));\n\tif (retval == NULL)\n\t\treturn NULL;\n\n\tif (!initialized) {\n\t\tinitialize_max_index ();\n\t\tinitialized = 1;\n\t}\n\n\tretval->size = 0;\n\tretval->root = new_radix_node (NULL, 0, 0);\n\tINIT_LIST_HEAD (&retval->head);\n\tif (retval->root == NULL) {\n\t\tfree (retval);\n\t\tretval = NULL;\n\t}\n\treturn retval;\n}\n\nstatic inline void delete_radix_data_node (struct radix_data_node *data) {\n\tlist_del (&data->iter_head);\n\tfree (data);\n}\n\nstatic inline void delete_radix_node (struct radix_node *node) {\n\tfree (node);\n}\n\n\/\/ BFS delete, no recursion\nvoid delete_radix_tree (struct radix_tree * tree) {\n\tstruct radix_node * node, *slot, **slots;\n\tstruct list_head rhead = LIST_HEAD_INIT (rhead);\n\tint i;\n\n\tnode = tree->root;\n\n\t\/\/ empty tree, don't traverse\n\tif (node == NULL)\n\t\tgoto out_skip_traversal;\n\n\t\/\/ enqueue root node\n\tlist_add_tail (&node->head, &rhead);\n\n\t\/\/ while queue is not empty\n\twhile (rhead.next != &rhead) {\n\t\t\/\/ pop head\n\t\tnode = container_of (rhead.next, struct radix_node, head);\n\t\tlist_del (&node->head);\n\t\tslots = node->slots;\n\t\tif (node->height > 0) {\n\t\t\tfor (i = 0, slot = slots[i];\n\t\t\t\t\ti < RT_BRANCH_FACTOR;\n\t\t\t\t\t++i, slot = slots[i])\n\t\t\t\tif (slot) {\n\t\t\t\t\tlist_add_tail (&slot->head, &rhead);\n\t\t\t\t}\n\t\t} else if (node->height == 0) {\n\t\t\t\/\/ if node->height == 0 -> children are data node, free the struct\n\t\t\tfor (i = 0, slot = slots[i];\n\t\t\t\t\ti < RT_BRANCH_FACTOR;\n\t\t\t\t\t++i, slot = slots[i])\n\t\t\t\tif (slot) {\n\t\t\t\t\tfree (slot);\n\t\t\t\t}\n\t\t} \/\/ else { TODO: dump some shits to debug this damn thing; }\n\t\tfree (node);\n\t}\n\nout_skip_traversal:\n\tfree (tree);\n}\n\nstatic inline struct radix_node * _rt_extend (struct radix_node *root) {\n\tstruct radix_node *retval = new_radix_node (NULL, root->height + 1, 0);\n\tif (retval == NULL)\n\t\treturn NULL;\n\tretval->slots[0] = root;\n\t++retval->child_count;\n\troot->parent = retval;\n\treturn retval;\n}\n\n\/**\n * shrink the tree from the leaf nodes\n *\/\nstatic inline void _rt_shrink_node (struct radix_node *node) {\n\tstruct radix_node *parent;\n\t\/**\n\t * Only shrink radix node without children\n\t *\/\n\twhile (node->child_count == 0) {\n\t\tparent = node->parent;\n\t\tif (parent == NULL)\n\t\t\treturn;\n\t\tparent->slots[node->offset] = NULL;\n\t\t--parent->child_count;\n\t\tdelete_radix_node (node);\n\t\tnode = parent;\n\t}\n}\n\n\/**\n * reduce tree height by shrinking from the root node\n *\/\nstatic inline void _rt_shrink_tree (struct radix_tree *tree) {\n\tstruct radix_node *rnode = tree->root;\n\t\/**\n\t * 1. Only shrink non-leaf root\n\t * 2. Don't shrink branching root\n\t * 3. Only shrink when root acts as zero prefix\n\t *\/","pos":1,"subs":[{"c.block_comment":{"text":"\/**\n * shrink the tree from the leaf nodes\n *\/","pos":3828,"subs":[{"c.block_comment_body":{"text":"*\n * shrink the tree from the leaf nodes\n ","pos":3830}}]}},{"c.block_comment":{"text":"\/**\n\t * Only shrink radix node without children\n\t *\/","pos":3967,"subs":[{"c.block_comment_body":{"text":"*\n\t * Only shrink radix node without children\n\t ","pos":3969}}]}},{"c.block_comment":{"text":"\/**\n * reduce tree height by shrinking from the root node\n *\/","pos":4226,"subs":[{"c.block_comment_body":{"text":"*\n * reduce tree height by shrinking from the root node\n ","pos":4228}}]}},{"c.block_comment":{"text":"\/**\n\t * 1. Only shrink non-leaf root\n\t * 2. Don't shrink branching root\n\t * 3. Only shrink when root acts as zero prefix\n\t *\/","pos":4392,"subs":[{"c.block_comment_body":{"text":"*\n\t * 1. Only shrink non-leaf root\n\t * 2. Don't shrink branching root\n\t * 3. Only shrink when root acts as zero prefix\n\t ","pos":4394}}]}}]}}
