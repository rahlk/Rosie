{"go.strings":{"pos":1,"subs":[{"go.string":{"pos":144,"text":"\"xml\""}},{"go.string":{"pos":151,"text":"\"os\""}},{"go.string":{"pos":157,"text":"\"log\""}},{"go.string":{"pos":175,"text":"\"flag\""}},{"go.string":{"pos":183,"text":"\"math\""}},{"go.string":{"pos":191,"text":"\"strings\""}},{"go.string":{"pos":202,"text":"\"strconv\""}},{"go.string":{"pos":213,"text":"\"runtime\""}},{"go.string":{"pos":224,"text":"\"archive\/zip\""}},{"go.string":{"pos":239,"text":"\"path\/filepath\""}},{"go.string":{"pos":256,"text":"\"compress\/bzip2\""}},{"go.string":{"pos":309,"text":"\"f\""}},{"go.string":{"pos":314,"text":"\"\""}},{"go.string":{"pos":318,"text":"\"You must specify an osm file - Required\""}},{"go.string":{"pos":386,"text":"\"b\""}},{"go.string":{"pos":391,"text":"\"\""}},{"go.string":{"pos":395,"text":"\"Bounds to limit OSM import. Format minlat,minlon,maxlat,maxlon\""}},{"go.string":{"pos":557,"text":"\"\""}},{"go.string":{"pos":598,"text":"\",\""}},{"go.string":{"pos":823,"text":"\"loadingWithBounds\""}},{"go.string":{"pos":917,"text":"\"\""}},{"go.string":{"pos":1321,"text":"\"nil Token ?\""}},{"go.string":{"pos":1472,"text":"\"way\""}},{"go.string":{"pos":1578,"text":"\"id\""}},{"go.string":{"pos":1702,"text":"\"nd\""}},{"go.string":{"pos":1816,"text":"\"ref\""}},{"go.string":{"pos":2070,"text":"\"tag\""}},{"go.string":{"pos":2211,"text":"\"k\""}},{"go.string":{"pos":2274,"text":"\"v\""}},{"go.string":{"pos":2332,"text":"\"\""}},{"go.string":{"pos":2347,"text":"\"\""}},{"go.string":{"pos":2380,"text":"\"highway\""}},{"go.string":{"pos":2423,"text":"\"motorway\""}},{"go.string":{"pos":2435,"text":"\"motorway_link\""}},{"go.string":{"pos":2452,"text":"\"trunk\""}},{"go.string":{"pos":2461,"text":"\"trunk_link\""}},{"go.string":{"pos":2475,"text":"\"primary\""}},{"go.string":{"pos":2486,"text":"\"primary_link\""}},{"go.string":{"pos":2502,"text":"\"secondary\""}},{"go.string":{"pos":2515,"text":"\"secondary_link\""}},{"go.string":{"pos":2533,"text":"\"tertiary\""}},{"go.string":{"pos":2646,"text":"\"node\""}},{"go.string":{"pos":2749,"text":"\"id\""}},{"go.string":{"pos":2847,"text":"\"lat\""}},{"go.string":{"pos":2949,"text":"\"lon\""}},{"go.string":{"pos":3235,"text":"\"Node count:\""}},{"go.string":{"pos":3385,"text":"\"Skipped node count:\""}},{"go.string":{"pos":3573,"text":"\"way\""}},{"go.string":{"pos":3724,"text":"\"Way count:\""}},{"go.string":{"pos":3824,"text":"\"new accepted way, node count:\""}},{"go.string":{"pos":4104,"text":"\"Node count:\""}},{"go.string":{"pos":4143,"text":"\"Skipped node count:\""}},{"go.string":{"pos":4197,"text":"\"Way count:\""}},{"go.string":{"pos":4362,"text":"\"Used nodes in ways count\""}},{"go.string":{"pos":4419,"text":"\"Used nodes in ways count\""}},{"go.string":{"pos":4481,"text":"\"Before GC - bytes = %d - footprint = %d\""}},{"go.string":{"pos":4615,"text":"\"Running GC\""}},{"go.string":{"pos":4655,"text":"\"After GC - bytes = %d - footprint = %d\""}},{"go.string":{"pos":4904,"text":"\".zip\""}},{"go.string":{"pos":5156,"text":"\".bz2\""}},{"go.string":{"pos":5180,"text":"\"Uncompressing and unmarshaling XML of zip file\""}},{"go.string":{"pos":5307,"text":"\"Unmarshaling XML of zip file\""}},{"go.string":{"pos":5546,"text":"\".bz2\""}},{"go.string":{"pos":5570,"text":"\"Uncompressing and unmarshaling XML\""}},{"go.string":{"pos":5687,"text":"\"Unmarshaling XML\""}}],"text":"\/\/ This code is MIT licensed and sourced from npaton\/goosm\n\n\/\/ 48.66,1.90,49.040,2.85\n\/\/ 48.8077,2.2467,48.9059,2.4245\npackage main\n\nimport (\n\t\"xml\"\n\t\"os\"\n\t\"log\"\n\t\/\/ \"time\"\n\t\"flag\"\n\t\"math\"\n\t\"strings\"\n\t\"strconv\"\n\t\"runtime\"\n\t\"archive\/zip\"\n\t\"path\/filepath\"\n\t\"compress\/bzip2\"\n)\n\nvar (\n\tfilenameptr = flag.String(\"f\", \"\", \"You must specify an osm file - Required\")\n\tboundsptr = flag.String(\"b\", \"\", \"Bounds to limit OSM import. Format minlat,minlon,maxlat,maxlon\")\n)\n\n\n\nfunc main() {\n\tflag.Parse()\n\tfilename := *filenameptr\n\tvar bounds Bounds\n\tif *boundsptr != \"\" {\n\t\tcomp := strings.Split(*boundsptr, \",\",-1)\n\t\tminlat, _ := strconv.Atof64(comp[0])\n\t\tminlon, _ := strconv.Atof64(comp[1])\n\t\tmaxlat, _ := strconv.Atof64(comp[2])\n\t\tmaxlon, _ := strconv.Atof64(comp[3])\n\t\tbounds = Bounds{minlat,minlon,maxlat,maxlon}\n\t\tlog.Println(\"loadingWithBounds\", bounds)\n\t} else {\n\t\tbounds = Bounds{-90,-180,90,180}\n\t}\n\n\tif filename == \"\" {\n\t\tflag.Usage()\n\t\tos.Exit(1)\n\t}\n\n\tresult := OSMFile{Ways:make([]Way,0)}\n\n\tparser := getParser(filename)\n\n\t\/\/ log.Println(\"parser\", parser)\n\n\ttoken, err := parser.Token()\n\tvar currentWay *Way\n\tshouldConserveCurrentWay := false\n\tskippedNodeCount := 0\n\tnodeCount := 0\n\twayCount := 0\n\tusedNodesCount := 0\n\tnodes := make(map[int]Node)\n\tfor err == nil {\n\n\t\tswitch token.(type) {\n\t\tcase nil:\n\t\t\tlog.Println(\"nil Token ?\")\n\t\t\tbreak\n\t\tcase xml.StartElement:\n\t\t\tstartElement, ok := token.(xml.StartElement)\n\t\t\tif !ok { break }\n\n\t\t\tif startElement.Name.Local == \"way\" {\n\t\t\t\tcurrentWay = new(Way)\n\t\t\t\tfor _, attr := range startElement.Attr {\n\t\t\t\t\tif attr.Name.Local == \"id\" {\n\t\t\t\t\t\tv, _ := strconv.Atoi(attr.Value)\n\t\t\t\t\t\tcurrentWay.Id = v\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else if startElement.Name.Local == \"nd\" {\n\t\t\t\tif currentWay == nil { break }\n\t\t\t\tfor _, attr := range startElement.Attr {\n\t\t\t\t\tif attr.Name.Local == \"ref\" {\n\t\t\t\t\t\tv, _ := strconv.Atoi(attr.Value)\n\t\t\t\t\t\tif foundNode, ok := nodes[v]; ok {\n\t\t\t\t\t\t\tcurrentWay.Nodes = append(currentWay.Nodes, foundNode)\n\t\t\t\t\t\t\tusedNodesCount = usedNodesCount + 1\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if startElement.Name.Local == \"tag\" {\n\t\t\t\tif currentWay == nil { break }\n\t\t\t\tvar key, value string\n\t\t\t\tfor _, attr := range startElement.Attr {\n\t\t\t\t\tif attr.Name.Local == \"k\" {\n\t\t\t\t\t\tkey = attr.Value\n\t\t\t\t\t} else if attr.Name.Local == \"v\" {\n\t\t\t\t\t\tvalue = attr.Value\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif key != \"\" && value != \"\" {\n\t\t\t\t\tswitch key {\n\t\t\t\t\tcase \"highway\":\n\t\t\t\t\t\tswitch value {\n\t\t\t\t\t\tcase \"motorway\", \"motorway_link\", \"trunk\", \"trunk_link\", \"primary\", \"primary_link\", \"secondary\", \"secondary_link\", \"tertiary\":\n\t\t\t\t\t\t\tshouldConserveCurrentWay = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else if startElement.Name.Local == \"node\" {\n\t\t\t\tnode := new(Node)\n\t\t\t\tfor _, attr := range startElement.Attr {\n\t\t\t\t\tif attr.Name.Local == \"id\" {\n\t\t\t\t\t\tv, _ := strconv.Atoi(attr.Value)\n\t\t\t\t\t\tnode.Id = v\n\t\t\t\t\t} else if attr.Name.Local == \"lat\" {\n\t\t\t\t\t\tv, _ := strconv.Atof64(attr.Value)\n\t\t\t\t\t\tnode.Lat = v\n\t\t\t\t\t} else if attr.Name.Local == \"lon\" {\n\t\t\t\t\t\tv, _ := strconv.Atof64(attr.Value)\n\t\t\t\t\t\tnode.Lon = v\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t\/\/ log.Println(\"Node\", node, node.Id, node.Lat, node.Lon)\n\n\t\t\t\tif node.Within(bounds) {\n\t\t\t\t\tnodes[node.Id] = *node\n\n\t\t\t\t\tnodeCount = nodeCount + 1\n\t\t\t\t\tif nodeCount % 100000 == 0 {\n\t\t\t\t\t\tlog.Println(\"Node count:\", nodeCount)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tskippedNodeCount = skippedNodeCount + 1\n\t\t\t\t\tif skippedNodeCount % 100000 == 0 {\n\t\t\t\t\t\tlog.Println(\"Skipped node count:\", skippedNodeCount)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tbreak\n\t\tcase xml.EndElement:\n\t\t\tendElement, ok := token.(xml.EndElement)\n\t\t\tif !ok { break }\n\n\t\t\tif endElement.Name.Local == \"way\" {\n\t\t\t\tif shouldConserveCurrentWay && len(currentWay.Nodes) > 5 {\n\t\t\t\t\twayCount = wayCount + 1\n\t\t\t\t\tif wayCount % 100000 == 0 {\n\t\t\t\t\t\tlog.Println(\"Way count:\", wayCount)\n\t\t\t\t\t}\n\t\t\t\t\tresult.Ways = append(result.Ways, *currentWay)\n\t\t\t\t\tlog.Println(\"new accepted way, node count:\", len(currentWay.Nodes))\n\t\t\t\t}\n\t\t\t\tcurrentWay = nil\n\t\t\t\tshouldConserveCurrentWay = false\n\t\t\t}\n\t\t\tbreak\n\t\tcase xml.CharData:\n\t\tcase xml.Comment:\n\t\tcase xml.ProcInst:\n\t\tcase xml.Directive:\n\t\t\tbreak\n\t\t}\n\n\t\ttoken, err = parser.Token()\n\t}\n\n\n\tlog.Println(\"Node count:\", nodeCount)\n\tlog.Println(\"Skipped node count:\", skippedNodeCount)\n\tlog.Println(\"Way count:\", wayCount)\n\treallyUsedNodesCount := 0\n\tfor _, way := range result.Ways {\n\t\treallyUsedNodesCount = reallyUsedNodesCount + len(way.Nodes)\n\t}\n\tlog.Println(\"Used nodes in ways count\", usedNodesCount)\n\tlog.Println(\"Used nodes in ways count\", reallyUsedNodesCount)\n\tlog.Printf(\"Before GC - bytes = %d - footprint = %d\", runtime.MemStats.HeapAlloc, runtime.MemStats.Sys)\n\tnodes = make(map[int]Node)\n\tlog.Println(\"Running GC\")\n\truntime.GC()\n\tlog.Printf(\"After GC - bytes = %d - footprint = %d\", runtime.MemStats.HeapAlloc, runtime.MemStats.Sys)\n\n\n\tif err != nil && err != os.EOF {\n\t\tpanic(err)\n\t}\n\n}\n\nfunc getParser(filename string) *xml.Parser {\n\tvar parser *xml.Parser\n\n\tif filepath.Ext(filename) == \".zip\" {\n\t\tzipcontainer, err := zip.OpenReader(filename)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tzippedfile := zipcontainer.File[0]\n\t\treader, err := zippedfile.Open()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tif filepath.Ext(zippedfile.FileHeader.Name) == \".bz2\" {\n\t\t\tlog.Println(\"Uncompressing and unmarshaling XML of zip file\")\n\t\t\tparser = xml.NewParser(bzip2.NewReader(reader))\n\t\t} else {\n\t\t\tlog.Println(\"Unmarshaling XML of zip file\")\n\t\t\tparser = xml.NewParser(reader)\n\t\t}\n\n\n\t\treader.Close()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t} else {\n\t\topenfile, err := os.Open(filename)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tif filepath.Ext(filename) == \".bz2\" {\n\t\t\tlog.Println(\"Uncompressing and unmarshaling XML\")\n\t\t\tparser = xml.NewParser(bzip2.NewReader(openfile))\n\t\t} else {\n\t\t\tlog.Println(\"Unmarshaling XML\")\n\t\t\tparser = xml.NewParser(openfile)\n\t\t}\n\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\treturn parser\n}\n\ntype OSMFile struct {\n\tBounds Bounds\n\tWays []Way\n}\n\ntype Bounds struct {\n\tMinlat float64\n\tMinlon float64\n\tMaxlat float64\n\tMaxlon float64\n}\n\n\ntype Node struct {\n\tId int\n\tLat float64\n\tLon float64\n}\n\nfunc (n *Node)Within(bounds Bounds) bool {\n\tif n.Lat >= bounds.Minlat && n.Lon >= bounds.Minlon && n.Lat <= bounds.Maxlat && n.Lon <= bounds.Maxlon {\n\t\treturn true\n\t}\n\treturn false\n}\n\ntype Way struct {\n\tId int\n\tNodes []Node\n}\n\ntype Point struct {\n\tX, Y float64\n}\n\n\nfunc (p Point)DistanceTo(other Point) float64 {\n\treturn math.Sqrt(math.Pow(math.Fabs(p.X - other.X), 2) + math.Pow(math.Fabs(p.Y - other.Y), 2))\n}\n\nfunc TriangleAltitude(A, B, C Point) float64 {\n\ta := A.DistanceTo(B)\n\tb := A.DistanceTo(C)\n\treturn a*b\/2*TriangleCircumradius(a, b, B.DistanceTo(C))\n}\n\n\/\/ TriangleCircumradius return the circumradius for the given triangle with edge lengths a, b and c\nfunc TriangleCircumradius(a, b, c float64) float64 {\n\treturn (a*b*c)\/math.Sqrt((a+b+c)*(b+c-a)*(c+a-b)*(a+b-c))\n}\n"}}
