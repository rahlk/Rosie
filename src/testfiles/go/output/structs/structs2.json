{"go.structs":{"text":"package solver\n\n\/\/ A local-search SAT solver based on tabu list\n\nimport (\n\t\"math\/rand\"\n\t\"time\"\n)\n\nfunc init() {\n\trand.Seed(time.Now().UnixNano())\n}\n\ntype Tabu struct {\n\tproblem      Problem\n\tmodel        Model\n\tnbUnsat      int \/\/ Current # of UNSAT clauses\n\tweightUnsat  int \/\/ Total weight of unsat clauses\n\tnbFlips      int \/\/ Total # of vars flipped\n\ttabuLength   int\n\tchanged      []int   \/\/ For each var, last time it was flipped\n\tunsatClauses []int   \/\/ Indexes of currently unsat clauses\n\twhereFalse   []int   \/\/ Where each clause is in unsatClauses\n\tappears      appears \/\/ Where each literal appears\n\tnbTrue       []int   \/\/ Nb of true lits in each clause\n\tbreakCount   []int   \/\/ For each var, total weight of broken clauses\n}\n\nfunc NewTabu(pb Problem, tabuLength int) *Tabu {\n\tmodel := randomModel(pb)\n\tappears := newAppears(pb)\n\tnbUnsat := 0\n\tweightUnsat := 0\n\tnbFlips := pb.NbVars \/\/ All vars are flipped on first random assignment\n\tchanged := make([]int, pb.NbVars)\n\tunsatClauses := make([]int, len(pb.Clauses))\n\twhereFalse := make([]int, len(pb.Clauses))\n\tnbTrue := make([]int, len(pb.Clauses))\n\tbreakCount := make([]int, pb.NbVars)\n\n\tfor i, clause := range pb.Clauses {\n\t\tvar unit Var \/\/ A var that could be the only true lit in the clause\n\t\tfor _, lit := range clause {\n\t\t\tv := lit.Var()\n\n\t\t\tif lit.Positive() == model[v] {\n\t\t\t\tunit = v\n\t\t\t\tnbTrue[i]++\n\t\t\t}\n\t\t}\n\n\t\tif nbTrue[i] == 0 {\n\t\t\tunsatClauses[nbUnsat] = i\n\t\t\twhereFalse[i] = nbUnsat\n\t\t\tnbUnsat++\n\t\t\tweightUnsat += pb.Weights[i]\n\t\t} else if nbTrue[i] == 1 {\n\t\t\t\/\/ Flipping that var would make the clause unsat\n\t\t\tbreakCount[unit] += pb.Weights[i]\n\t\t}\n\t}\n\n\treturn &Tabu{\n\t\tpb,\n\t\tmodel,\n\t\tnbUnsat,\n\t\tweightUnsat,\n\t\tnbFlips,\n\t\ttabuLength,\n\t\tchanged,\n\t\tunsatClauses,\n\t\twhereFalse,\n\t\tappears,\n\t\tnbTrue,\n\t\tbreakCount,\n\t}\n}\n\nfunc (s *Tabu) Score() int {\n\treturn s.weightUnsat\n}\n\n\/\/ Picks and returns a variable to flip\n\/\/ Vars are chosen from a random unsat clause\n\/\/ If all lits from the clause are tabu,\n\/\/ No var is return and ok is false.\n\/\/ Else, ok is true and a var is returned\nfunc (s *Tabu) pick() (res Var, ok bool) {\n\tidx := s.unsatClauses[rand.Intn(s.nbUnsat)]\n\tcl := s.problem.Clauses[idx]\n\ttop := make([]Var, len(cl))\n\tnbTop := 0\n\tvar best int\n\n\tfor i := 0; i < len(cl); i++ {\n\t\tv := cl[i].Var()\n\t\tbreakCount := s.breakCount[v]\n\n\t\tif breakCount == 0 {\n\t\t\tif best > 0 {\n\t\t\t\tbest = 0\n\t\t\t\tnbTop = 1\n\t\t\t\ttop[0] = v\n\t\t\t} else {\n\t\t\t\ttop[nbTop] = v\n\t\t\t\tnbTop++\n\t\t\t}\n\t\t} else if s.tabuLength < s.nbFlips-s.changed[cl[i].Var()] {\n\t\t\tif nbTop == 0 || breakCount < best {\n\t\t\t\tbest = breakCount\n\t\t\t\tnbTop = 1\n\t\t\t\ttop[0] = v\n\t\t\t} else if breakCount == best {\n\t\t\t\ttop[nbTop] = v\n\t\t\t\tnbTop++\n\t\t\t}\n\t\t}\n\t}\n\n\tif nbTop == 0 {\n\t\treturn res, false\n\t} else if nbTop == 1 {\n\t\treturn top[0], true\n\t} else {\n\t\treturn top[rand.Intn(nbTop)], true\n\t}\n}\n\nfunc (s *Tabu) flip(v Var) {\n\ts.nbFlips++\n\ts.changed[v] = s.nbFlips\n\ts.model[v] = !s.model[v]\n\tnewLit := v.Lit(!s.model[v])\n\toldLit := newLit.Negation()\n\tnewAppears := s.appears.get(newLit)\n\toldAppears := s.appears.get(oldLit)\n\n\tfor _, idx := range newAppears {\n\t\ts.nbTrue[idx]++\n\n\t\tif s.nbTrue[idx] == 1 {\n\t\t\t\/\/ Clause was broken, it is now sat but will be broken by a flip of v\n\t\t\ts.breakCount[v] += s.problem.Weights[idx]\n\t\t\ts.nbUnsat--\n\t\t\ts.weightUnsat -= s.problem.Weights[idx]\n\t\t\ts.unsatClauses[s.whereFalse[idx]] = s.unsatClauses[s.nbUnsat]\n\t\t\ts.whereFalse[s.unsatClauses[s.nbUnsat]] = s.whereFalse[idx]\n\t\t} else if s.nbTrue[idx] == 2 {\n\t\t\t\/\/ Another var would have made the clause broken\n\t\t\t\/\/ Find it, decrement its breakcount\n\t\t\tclause := s.problem.Clauses[idx]\n\n\t\t\tfor _, lit := range clause {\n\t\t\t\tvi := lit.Var()\n\n\t\t\t\tif vi != v && lit.Positive() == s.model[vi] {\n\t\t\t\t\ts.breakCount[vi] -= s.problem.Weights[idx]\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, idx := range oldAppears {\n\t\ts.nbTrue[idx]--\n\n\t\tif s.nbTrue[idx] == 0 {\n\t\t\ts.unsatClauses[s.nbUnsat] = idx\n\t\t\ts.whereFalse[idx] = s.nbUnsat\n\t\t\ts.nbUnsat++\n\t\t\ts.weightUnsat += s.problem.Weights[idx]\n\t\t\t\/\/ That clause cannot be broken : it *is* broken\n\t\t\ts.breakCount[v] -= s.problem.Weights[idx]\n\t\t} else if s.nbTrue[idx] == 1 {\n\t\t\t\/\/ Clause will be broken if last lit is flipped\n\t\t\t\/\/ Find it and update breakCount\n\t\t\tclause := s.problem.Clauses[idx]\n\n\t\t\tfor _, lit := range clause {\n\t\t\t\tvi := lit.Var()\n\n\t\t\t\tif s.model[vi] == lit.Positive() {\n\t\t\t\t\t\/\/ It is the only positive lit in the clause\n\t\t\t\t\ts.breakCount[vi] += s.problem.Weights[idx]\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (s *Tabu) Solve(nbTries int) Model {\n\tfor i := 0; i < nbTries && s.nbUnsat > 0; i++ {\n\t\tv, ok := s.pick()\n\n\t\tif ok {\n\t\t\ts.flip(v)\n\t\t}\n\t}\n\n\treturn s.model\n}","subs":[{"go.struct":{"text":"type Tabu struct ","subs":[{"go.struct_name":{"text":"Tabu ","pos":155}}],"pos":150}}],"pos":1}}
