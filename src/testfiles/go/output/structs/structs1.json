{"go.structs":{"text":"package solver\n\n\/\/ A local-search MAX-SAT solver based on simulated annealing\n\nimport (\n\t\/\/\"fmt\"\n\t\"math\"\n\t\"math\/rand\"\n\t\"time\"\n)\n\nfunc init() {\n\trand.Seed(time.Now().UnixNano())\n}\n\ntype AnnealingSolver struct {\n\tproblem      Problem\n\tmodel        Model\n\tnbUnsat      int     \/\/ Current # of UNSAT clauses\n\tweightUnsat  int     \/\/ Total weight of unsat clauses\n\tunsatClauses []int   \/\/ Indexes of currently unsat clauses\n\twhereFalse   []int   \/\/ Where each clause is in unsatClauses\n\tappears      appears \/\/ Where each literal appears\n\tnbTrue       []int   \/\/ Nb of true lits in each clause\n\tbreakCount   []int   \/\/ For each var, total weight of broken clauses\n\tmakeCount    []int   \/\/ For each var, total weight of clauses that would be true if flipped\n}\n\nfunc NewAnnealingSolver(pb Problem) *AnnealingSolver {\n\tmodel := randomModel(pb)\n\tappears := newAppears(pb)\n\tnbUnsat := 0\n\tweightUnsat := 0\n\tunsatClauses := make([]int, len(pb.Clauses))\n\twhereFalse := make([]int, len(pb.Clauses))\n\tnbTrue := make([]int, len(pb.Clauses))\n\tbreakCount := make([]int, pb.NbVars)\n\tmakeCount := make([]int, pb.NbVars)\n\n\tfor i, clause := range pb.Clauses {\n\t\tvar unit Var \/\/ A var that could be the only true lit in the clause\n\n\t\tfor _, lit := range clause {\n\t\t\tv := lit.Var()\n\n\t\t\tif lit.Positive() == model[v] {\n\t\t\t\tunit = v\n\t\t\t\tnbTrue[i]++\n\t\t\t}\n\t\t}\n\n\t\tif nbTrue[i] == 0 {\n\t\t\tunsatClauses[nbUnsat] = i\n\t\t\twhereFalse[i] = nbUnsat\n\t\t\tnbUnsat++\n\t\t\tweightUnsat += pb.Weights[i]\n\n\t\t\tfor _, lit := range clause {\n\t\t\t\tmakeCount[lit.Var()] += pb.Weights[i]\n\t\t\t}\n\t\t} else if nbTrue[i] == 1 {\n\t\t\t\/\/ Flipping that var would make the clause unsat\n\t\t\tbreakCount[unit] += pb.Weights[i]\n\t\t}\n\t}\n\n\treturn &AnnealingSolver{\n\t\tpb,\n\t\tmodel,\n\t\tnbUnsat,\n\t\tweightUnsat,\n\t\tunsatClauses,\n\t\twhereFalse,\n\t\tappears,\n\t\tnbTrue,\n\t\tbreakCount,\n\t\tmakeCount,\n\t}\n}\n\nfunc (s *AnnealingSolver) Score() int {\n\treturn s.weightUnsat\n}\n\nfunc (s *AnnealingSolver) flip(v Var) {\n\ts.model[v] = !s.model[v]\n\tnewLit := v.Lit(!s.model[v])\n\toldLit := newLit.Negation()\n\n\tfor _, idx := range s.appears.get(newLit) {\n\t\ts.nbTrue[idx]++\n\t\tweight := s.problem.Weights[idx]\n\n\t\tif s.nbTrue[idx] == 1 {\n\t\t\t\/\/ Clause was broken, it is now sat but will be broken by a flip of v\n\t\t\ts.breakCount[v] += weight\n\t\t\ts.nbUnsat--\n\t\t\ts.weightUnsat -= weight\n\t\t\ts.unsatClauses[s.whereFalse[idx]] = s.unsatClauses[s.nbUnsat]\n\t\t\ts.whereFalse[s.unsatClauses[s.nbUnsat]] = s.whereFalse[idx]\n\n\t\t\t\/\/ Flipping lits won't make the clause true anymore\n\t\t\tfor _, lit := range s.problem.Clauses[idx] {\n\t\t\t\ts.makeCount[lit.Var()] -= weight\n\t\t\t}\n\t\t} else if s.nbTrue[idx] == 2 {\n\t\t\t\/\/ Another var would have made the clause broken\n\t\t\t\/\/ Find it, decrement its breakcount\n\t\t\tfor _, lit := range s.problem.Clauses[idx] {\n\t\t\t\tvi := lit.Var()\n\n\t\t\t\tif vi != v && lit.Positive() == s.model[vi] {\n\t\t\t\t\ts.breakCount[vi] -= weight\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, idx := range s.appears.get(oldLit) {\n\t\ts.nbTrue[idx]--\n\t\tweight := s.problem.Weights[idx]\n\n\t\tif s.nbTrue[idx] == 0 {\n\t\t\ts.unsatClauses[s.nbUnsat] = idx\n\t\t\ts.whereFalse[idx] = s.nbUnsat\n\t\t\ts.nbUnsat++\n\t\t\ts.weightUnsat += weight\n\t\t\t\/\/ That clause cannot be broken : it *is* broken\n\t\t\ts.breakCount[v] -= weight\n\n\t\t\t\/\/ Any lit can make this clause true\n\t\t\tfor _, lit := range s.problem.Clauses[idx] {\n\t\t\t\ts.makeCount[lit.Var()] += weight\n\t\t\t}\n\t\t} else if s.nbTrue[idx] == 1 {\n\t\t\t\/\/ Clause will be broken if last lit is flipped\n\t\t\t\/\/ Find it and update breakCount\n\t\t\tfor _, lit := range s.problem.Clauses[idx] {\n\t\t\t\tvi := lit.Var()\n\n\t\t\t\tif s.model[vi] == lit.Positive() {\n\t\t\t\t\t\/\/ It is the only positive lit in the clause\n\t\t\t\t\ts.breakCount[vi] += weight\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (s *AnnealingSolver) Solve(nbTries int) Model {\n\tt := 1.0\n\t\/\/fmt.Printf(\"Score=%d, model=%v\\n\", s.weightUnsat, s.model)\n\n\tfor i := 1; i <= nbTries; i++ {\n\t\tv := Var(rand.Intn(s.problem.NbVars))\n\t\t\/\/fmt.Printf(\"Chose var %d that would break %d and make %d\\n\", v, s.breakCount[v], s.makeCount[v])\n\t\tdelta := float64(s.makeCount[v]-s.breakCount[v]) \/ float64(s.problem.NbVars)\n\t\tt *= 0.99\n\t\t\/\/fmt.Printf(\"t=%g, delta=%g, p=%g\\n\", t, delta, proba(delta, t))\n\n\t\tif proba(delta, t) > rand.Float64() {\n\t\t\ts.flip(v)\n\t\t\t\/\/fmt.Printf(\"Flipped, score=%d model=%v\\n\", s.weightUnsat, s.model)\n\t\t}\n\t}\n\n\treturn s.model\n}\n\nfunc proba(delta, temp float64) float64 {\n\tif delta >= 0 {\n\t\treturn 1.0\n\t} else {\n\t\tnum := 1 - delta\n\t\treturn math.Exp(-num \/ temp)\n\t}\n}","subs":[{"go.struct":{"text":"type AnnealingSolver struct ","subs":[{"go.struct_name":{"text":"AnnealingSolver ","pos":186}}],"pos":181}}],"pos":1}}
