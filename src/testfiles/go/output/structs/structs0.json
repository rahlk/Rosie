{"go.structs":{"text":"\/\/ This code is MIT licensed and sourced from npaton\/goosm\n\n\/\/ 48.66,1.90,49.040,2.85\n\/\/ 48.8077,2.2467,48.9059,2.4245\npackage main\n\nimport (\n\t\"xml\"\n\t\"os\"\n\t\"log\"\n\t\/\/ \"time\"\n\t\"flag\"\n\t\"math\"\n\t\"strings\"\n\t\"strconv\"\n\t\"runtime\"\n\t\"archive\/zip\"\n\t\"path\/filepath\"\n\t\"compress\/bzip2\"\n)\n\nvar (\n\tfilenameptr = flag.String(\"f\", \"\", \"You must specify an osm file - Required\")\n\tboundsptr = flag.String(\"b\", \"\", \"Bounds to limit OSM import. Format minlat,minlon,maxlat,maxlon\")\n)\n\n\n\nfunc main() {\n\tflag.Parse()\n\tfilename := *filenameptr\n\tvar bounds Bounds\n\tif *boundsptr != \"\" {\n\t\tcomp := strings.Split(*boundsptr, \",\",-1)\n\t\tminlat, _ := strconv.Atof64(comp[0])\n\t\tminlon, _ := strconv.Atof64(comp[1])\n\t\tmaxlat, _ := strconv.Atof64(comp[2])\n\t\tmaxlon, _ := strconv.Atof64(comp[3])\n\t\tbounds = Bounds{minlat,minlon,maxlat,maxlon}\n\t\tlog.Println(\"loadingWithBounds\", bounds)\n\t} else {\n\t\tbounds = Bounds{-90,-180,90,180}\n\t}\n\n\tif filename == \"\" {\n\t\tflag.Usage()\n\t\tos.Exit(1)\n\t}\n\n\tresult := OSMFile{Ways:make([]Way,0)}\n\n\tparser := getParser(filename)\n\n\t\/\/ log.Println(\"parser\", parser)\n\n\ttoken, err := parser.Token()\n\tvar currentWay *Way\n\tshouldConserveCurrentWay := false\n\tskippedNodeCount := 0\n\tnodeCount := 0\n\twayCount := 0\n\tusedNodesCount := 0\n\tnodes := make(map[int]Node)\n\tfor err == nil {\n\n\t\tswitch token.(type) {\n\t\tcase nil:\n\t\t\tlog.Println(\"nil Token ?\")\n\t\t\tbreak\n\t\tcase xml.StartElement:\n\t\t\tstartElement, ok := token.(xml.StartElement)\n\t\t\tif !ok { break }\n\n\t\t\tif startElement.Name.Local == \"way\" {\n\t\t\t\tcurrentWay = new(Way)\n\t\t\t\tfor _, attr := range startElement.Attr {\n\t\t\t\t\tif attr.Name.Local == \"id\" {\n\t\t\t\t\t\tv, _ := strconv.Atoi(attr.Value)\n\t\t\t\t\t\tcurrentWay.Id = v\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else if startElement.Name.Local == \"nd\" {\n\t\t\t\tif currentWay == nil { break }\n\t\t\t\tfor _, attr := range startElement.Attr {\n\t\t\t\t\tif attr.Name.Local == \"ref\" {\n\t\t\t\t\t\tv, _ := strconv.Atoi(attr.Value)\n\t\t\t\t\t\tif foundNode, ok := nodes[v]; ok {\n\t\t\t\t\t\t\tcurrentWay.Nodes = append(currentWay.Nodes, foundNode)\n\t\t\t\t\t\t\tusedNodesCount = usedNodesCount + 1\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if startElement.Name.Local == \"tag\" {\n\t\t\t\tif currentWay == nil { break }\n\t\t\t\tvar key, value string\n\t\t\t\tfor _, attr := range startElement.Attr {\n\t\t\t\t\tif attr.Name.Local == \"k\" {\n\t\t\t\t\t\tkey = attr.Value\n\t\t\t\t\t} else if attr.Name.Local == \"v\" {\n\t\t\t\t\t\tvalue = attr.Value\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif key != \"\" && value != \"\" {\n\t\t\t\t\tswitch key {\n\t\t\t\t\tcase \"highway\":\n\t\t\t\t\t\tswitch value {\n\t\t\t\t\t\tcase \"motorway\", \"motorway_link\", \"trunk\", \"trunk_link\", \"primary\", \"primary_link\", \"secondary\", \"secondary_link\", \"tertiary\":\n\t\t\t\t\t\t\tshouldConserveCurrentWay = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else if startElement.Name.Local == \"node\" {\n\t\t\t\tnode := new(Node)\n\t\t\t\tfor _, attr := range startElement.Attr {\n\t\t\t\t\tif attr.Name.Local == \"id\" {\n\t\t\t\t\t\tv, _ := strconv.Atoi(attr.Value)\n\t\t\t\t\t\tnode.Id = v\n\t\t\t\t\t} else if attr.Name.Local == \"lat\" {\n\t\t\t\t\t\tv, _ := strconv.Atof64(attr.Value)\n\t\t\t\t\t\tnode.Lat = v\n\t\t\t\t\t} else if attr.Name.Local == \"lon\" {\n\t\t\t\t\t\tv, _ := strconv.Atof64(attr.Value)\n\t\t\t\t\t\tnode.Lon = v\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t\/\/ log.Println(\"Node\", node, node.Id, node.Lat, node.Lon)\n\n\t\t\t\tif node.Within(bounds) {\n\t\t\t\t\tnodes[node.Id] = *node\n\n\t\t\t\t\tnodeCount = nodeCount + 1\n\t\t\t\t\tif nodeCount % 100000 == 0 {\n\t\t\t\t\t\tlog.Println(\"Node count:\", nodeCount)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tskippedNodeCount = skippedNodeCount + 1\n\t\t\t\t\tif skippedNodeCount % 100000 == 0 {\n\t\t\t\t\t\tlog.Println(\"Skipped node count:\", skippedNodeCount)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tbreak\n\t\tcase xml.EndElement:\n\t\t\tendElement, ok := token.(xml.EndElement)\n\t\t\tif !ok { break }\n\n\t\t\tif endElement.Name.Local == \"way\" {\n\t\t\t\tif shouldConserveCurrentWay && len(currentWay.Nodes) > 5 {\n\t\t\t\t\twayCount = wayCount + 1\n\t\t\t\t\tif wayCount % 100000 == 0 {\n\t\t\t\t\t\tlog.Println(\"Way count:\", wayCount)\n\t\t\t\t\t}\n\t\t\t\t\tresult.Ways = append(result.Ways, *currentWay)\n\t\t\t\t\tlog.Println(\"new accepted way, node count:\", len(currentWay.Nodes))\n\t\t\t\t}\n\t\t\t\tcurrentWay = nil\n\t\t\t\tshouldConserveCurrentWay = false\n\t\t\t}\n\t\t\tbreak\n\t\tcase xml.CharData:\n\t\tcase xml.Comment:\n\t\tcase xml.ProcInst:\n\t\tcase xml.Directive:\n\t\t\tbreak\n\t\t}\n\n\t\ttoken, err = parser.Token()\n\t}\n\n\n\tlog.Println(\"Node count:\", nodeCount)\n\tlog.Println(\"Skipped node count:\", skippedNodeCount)\n\tlog.Println(\"Way count:\", wayCount)\n\treallyUsedNodesCount := 0\n\tfor _, way := range result.Ways {\n\t\treallyUsedNodesCount = reallyUsedNodesCount + len(way.Nodes)\n\t}\n\tlog.Println(\"Used nodes in ways count\", usedNodesCount)\n\tlog.Println(\"Used nodes in ways count\", reallyUsedNodesCount)\n\tlog.Printf(\"Before GC - bytes = %d - footprint = %d\", runtime.MemStats.HeapAlloc, runtime.MemStats.Sys)\n\tnodes = make(map[int]Node)\n\tlog.Println(\"Running GC\")\n\truntime.GC()\n\tlog.Printf(\"After GC - bytes = %d - footprint = %d\", runtime.MemStats.HeapAlloc, runtime.MemStats.Sys)\n\n\n\tif err != nil && err != os.EOF {\n\t\tpanic(err)\n\t}\n\n}\n\nfunc getParser(filename string) *xml.Parser {\n\tvar parser *xml.Parser\n\n\tif filepath.Ext(filename) == \".zip\" {\n\t\tzipcontainer, err := zip.OpenReader(filename)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tzippedfile := zipcontainer.File[0]\n\t\treader, err := zippedfile.Open()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tif filepath.Ext(zippedfile.FileHeader.Name) == \".bz2\" {\n\t\t\tlog.Println(\"Uncompressing and unmarshaling XML of zip file\")\n\t\t\tparser = xml.NewParser(bzip2.NewReader(reader))\n\t\t} else {\n\t\t\tlog.Println(\"Unmarshaling XML of zip file\")\n\t\t\tparser = xml.NewParser(reader)\n\t\t}\n\n\n\t\treader.Close()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t} else {\n\t\topenfile, err := os.Open(filename)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tif filepath.Ext(filename) == \".bz2\" {\n\t\t\tlog.Println(\"Uncompressing and unmarshaling XML\")\n\t\t\tparser = xml.NewParser(bzip2.NewReader(openfile))\n\t\t} else {\n\t\t\tlog.Println(\"Unmarshaling XML\")\n\t\t\tparser = xml.NewParser(openfile)\n\t\t}\n\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\treturn parser\n}\n\ntype OSMFile struct {\n\tBounds Bounds\n\tWays []Way\n}\n\ntype Bounds struct {\n\tMinlat float64\n\tMinlon float64\n\tMaxlat float64\n\tMaxlon float64\n}\n\n\ntype Node struct {\n\tId int\n\tLat float64\n\tLon float64\n}\n\nfunc (n *Node)Within(bounds Bounds) bool {\n\tif n.Lat >= bounds.Minlat && n.Lon >= bounds.Minlon && n.Lat <= bounds.Maxlat && n.Lon <= bounds.Maxlon {\n\t\treturn true\n\t}\n\treturn false\n}\n\ntype Way struct {\n\tId int\n\tNodes []Node\n}\n\ntype Point struct {\n\tX, Y float64\n}\n\n\nfunc (p Point)DistanceTo(other Point) float64 {\n\treturn math.Sqrt(math.Pow(math.Fabs(p.X - other.X), 2) + math.Pow(math.Fabs(p.Y - other.Y), 2))\n}\n\nfunc TriangleAltitude(A, B, C Point) float64 {\n\ta := A.DistanceTo(B)\n\tb := A.DistanceTo(C)\n\treturn a*b\/2*TriangleCircumradius(a, b, B.DistanceTo(C))\n}\n\n\/\/ TriangleCircumradius return the circumradius for the given triangle with edge lengths a, b and c\nfunc TriangleCircumradius(a, b, c float64) float64 {\n\treturn (a*b*c)\/math.Sqrt((a+b+c)*(b+c-a)*(c+a-b)*(a+b-c))\n}\n","subs":[{"go.struct":{"text":"type OSMFile struct ","subs":[{"go.struct_name":{"text":"OSMFile ","pos":5810}}],"pos":5805}},{"go.struct":{"text":"type Bounds struct ","subs":[{"go.struct_name":{"text":"Bounds ","pos":5862}}],"pos":5857}},{"go.struct":{"text":"type Node struct ","subs":[{"go.struct_name":{"text":"Node ","pos":5951}}],"pos":5946}},{"go.struct":{"text":"type Way struct ","subs":[{"go.struct_name":{"text":"Way ","pos":6191}}],"pos":6186}},{"go.struct":{"text":"type Point struct ","subs":[{"go.struct_name":{"text":"Point ","pos":6234}}],"pos":6229}}],"pos":1}}
